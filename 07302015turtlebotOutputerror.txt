run:
Aug 02, 2015 3:07:01 PM org.happy.artist.rmdmia.rcsm.RCSMManager <init>
INFO: Starting RCSM...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.rcsm.RCSMProperties readPropertiesFile
INFO: RCSM Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/rcsm.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.instruction.InstructionManager <init>
INFO: Starting Instruction Manager...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.instruction.InstructionManagerProperties readPropertiesFile
INFO: Instruction Manager Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/instruction_manager.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.perception.engine.PEManager <init>
INFO: Starting Perception Engine...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.perception.engine.PEProperties readPropertiesFile
INFO: Perception Engine Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/pe.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.roci.ROCIManager <init>
INFO: Starting ROCI...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.roci.ROCIProperties readPropertiesFile
INFO: ROCI Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/roci.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.gesture.manager.GestureManager <init>
INFO: Starting Gesture Manager...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.gesture.manager.GestureManagerProperties readPropertiesFile
INFO: Gesture Manager Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/gesture_manager.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.decision.manager.DecisionManager <init>
INFO: Starting Decision Manager...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.decision.manager.DecisionManagerProperties readPropertiesFile
INFO: Decision Manager Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/decision_manager.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.mission.manager.MissionManager <init>
INFO: Starting Mission Manager...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.mission.manager.MissionManagerProperties readPropertiesFile
INFO: Mission Manager Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/mission_manager.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.task.manager.TaskManager <init>
INFO: Starting Task Manager...
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.task.manager.TaskManagerProperties readPropertiesFile
INFO: Task Manager Properties: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/task_manager.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.rcsm.RCSMManager initialize
INFO: Starting RCSM Plugin: ros_v1.0
ros_v1.0 Properties: conf/rcsm/ros_v1.0.properties
Aug 02, 2015 3:07:02 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.TopicRegistry readPropertiesFile
INFO: ROSNode Topic Registry File path: /home/aaron/NetBeansProjects/RMDMIA/projects/RMDMIA_DEBUG/conf/rcsm/ros/topic_registry.eax
Aug 02, 2015 3:07:06 PM org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode initialize
INFO: PID: 2073
Aug 02, 2015 3:07:09 PM org.happy.artist.rmdmia.instruction.InstructionManager initialize
INFO: Starting Instruction Manager Provider: instruction_manager_v1.0
instruction_manager_v1.0 Properties: conf/im/instruction_manager_v1.0.properties
Aug 02, 2015 3:07:09 PM org.happy.artist.rmdmia.instruction.providers.InstructionManagerPlugin initialize
INFO: Initializing Instruction Manager plugin.
InstructionManagerProperties keys length is less than 1. Generating default values.
Aug 02, 2015 3:07:09 PM org.happy.artist.rmdmia.instruction.utility.Utility generateDefaultInstructionManagerTopicsWithROSPlugin
INFO: Populating the default Instruction Manager registry instruction_manager.properties.
Aug 02, 2015 3:07:11 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
Aug 02, 2015 3:07:11 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
Aug 02, 2015 3:07:11 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
OutputHandler:
package ros.std_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.std_msgs.Empty;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class EmptyOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private EmptyInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Empty this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public EmptyOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(EmptyInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
Aug 02, 2015 3:07:11 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
SEVERE: getFilePath(): null
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            EmptyOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.geometry_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.geometry_msgs.Twist;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class TwistOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private TwistInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Twist this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public TwistOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(TwistInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);



    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
Aug 02, 2015 3:07:14 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
Aug 02, 2015 3:07:14 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
     */
SEVERE: getFilePath(): null
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            TwistOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private long float64Long;
}


OutputHandler:
package ros.geometry_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.geometry_msgs.Twist;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class TwistOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private TwistInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Twist this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public TwistOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(TwistInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);



    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            TwistOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private long float64Long;
}


OutputHandler:
package ros.geometry_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.geometry_msgs.Twist;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class TwistOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private TwistInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Twist this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public TwistOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(TwistInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);



    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            TwistOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private long float64Long;
}


VARIABLE: string
OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.Image;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class ImageOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private ImageInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Image this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public ImageOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(ImageInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.encoding.length()+1)/2)+4) +(1) +(4) +((this_instruction.data.length*1)+4) ];
this.this_instruction=(Image)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.encoding.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.encoding);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.is_bigendian >>> 0) & 0xff);
current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ImageOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.encoding.length()+1)/2)+4) +(1) +(4) +((this_instruction.data.length*1)+4) ];
this.this_instruction=(Image)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.encoding.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.encoding);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.is_bigendian >>> 0) & 0xff);
current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ImageOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.encoding.length()+1)/2)+4) +(1) +(4) +((this_instruction.data.length*1)+4) ];
this.this_instruction=(Image)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.encoding.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.encoding);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.is_bigendian >>> 0) & 0xff);
current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            ImageOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int array_length;
private byte int8Byte;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/twist, Schema File: # This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

Found sub-child custom schema Object location for: ros/geometry_msgs/twist, Schema File: # This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/twist, Schema File: # This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

Found sub-child custom schema Object location for: ros/geometry_msgs/twist, Schema File: # This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/vector3, Schema File: # This represents a vector in free space. 

float64 x
float64 y
float64 z

OutputHandler:
package ros.nav_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.nav_msgs.Odometry;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class OdometryOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private OdometryInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Odometry this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public OdometryOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(OdometryInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[588];
this.this_instruction=(Odometry)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.child_frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.child_frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[0]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[1]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[2]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[3]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[4]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[5]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[6]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[7]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[8]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[9]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[10]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[11]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[12]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[13]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[14]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[15]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[16]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[17]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[18]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[19]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[20]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[21]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[22]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[23]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[24]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[25]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[26]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[27]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[28]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[29]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[30]);
ros_msg[296] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[297] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[298] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[299] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[300] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[301] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[302] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[303] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[31]);
ros_msg[304] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[305] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[306] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[307] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[308] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[309] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[310] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[311] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[32]);
ros_msg[312] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[313] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[314] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[315] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[316] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[317] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[318] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[319] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[33]);
ros_msg[320] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[321] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[322] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[323] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[324] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[325] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[326] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[327] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[34]);
ros_msg[328] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[329] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[330] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[331] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[332] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[333] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[334] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[335] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[35]);
ros_msg[336] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[337] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[338] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[339] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[340] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[341] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[342] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[343] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.x);
ros_msg[344] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[345] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[346] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[347] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[348] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[349] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[350] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[351] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.y);
ros_msg[352] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[353] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[354] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[355] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[356] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[357] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[358] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[359] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.z);
ros_msg[360] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[361] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[362] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[363] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[364] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[365] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[366] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[367] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.x);
ros_msg[368] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[369] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[370] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[371] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[372] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[373] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[374] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[375] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.y);
ros_msg[376] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[377] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[378] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[379] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[380] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[381] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[382] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[383] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.z);
ros_msg[384] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[385] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[386] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[387] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[388] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[389] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[390] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[391] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[0]);
ros_msg[392] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[393] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[394] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[395] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[396] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[397] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[398] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[399] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[1]);
ros_msg[400] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[401] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[402] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[403] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[404] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[405] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[406] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[407] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[2]);
ros_msg[408] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[409] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[410] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[411] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[412] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[413] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[414] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[415] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[3]);
ros_msg[416] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[417] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[418] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[419] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[420] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[421] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[422] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[423] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[4]);
ros_msg[424] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[425] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[426] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[427] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[428] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[429] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[430] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[431] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[5]);
ros_msg[432] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[433] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[434] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[435] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[436] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[437] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[438] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[439] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[6]);
ros_msg[440] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[441] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[442] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[443] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[444] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[445] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[446] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[447] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[7]);
ros_msg[448] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[449] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[450] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[451] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[452] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[453] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[454] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[455] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[8]);
ros_msg[456] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[457] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[458] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[459] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[460] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[461] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[462] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[463] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[9]);
ros_msg[464] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[465] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[466] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[467] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[468] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[469] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[470] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[471] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[10]);
ros_msg[472] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[473] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[474] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[475] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[476] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[477] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[478] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[479] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[11]);
ros_msg[480] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[481] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[482] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[483] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[484] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[485] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[486] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[487] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[12]);
ros_msg[488] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[489] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[490] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[491] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[492] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[493] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[494] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[495] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[13]);
ros_msg[496] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[497] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[498] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[499] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[500] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[501] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[502] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[503] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[14]);
ros_msg[504] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[505] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[506] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[507] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[508] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[509] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[510] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[511] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[15]);
ros_msg[512] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[513] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[514] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[515] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[516] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[517] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[518] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[519] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[16]);
ros_msg[520] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[521] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[522] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[523] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[524] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[525] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[526] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[527] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[17]);
ros_msg[528] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[529] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[530] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[531] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[532] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[533] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[534] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[535] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[18]);
ros_msg[536] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[537] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[538] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[539] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[540] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[541] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[542] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[543] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[19]);
ros_msg[544] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[545] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[546] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[547] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[548] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[549] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[550] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[551] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[20]);
ros_msg[552] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[553] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[554] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[555] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[556] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[557] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[558] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[559] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[21]);
ros_msg[560] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[561] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[562] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[563] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[564] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[565] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[566] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[567] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[22]);
ros_msg[568] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[569] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[570] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[571] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[572] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[573] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[574] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[575] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[23]);
ros_msg[576] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[577] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[578] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[579] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[580] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[581] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[582] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[583] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[24]);
ros_msg[584] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[585] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[586] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[587] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[588] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[589] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[590] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[591] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[25]);
ros_msg[592] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[593] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[594] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[595] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[596] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[597] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[598] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[599] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[26]);
ros_msg[600] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[601] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[602] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[603] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[604] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[605] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[606] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[607] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[27]);
ros_msg[608] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[609] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[610] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[611] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[612] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[613] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[614] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[615] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[28]);
ros_msg[616] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[617] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[618] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[619] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[620] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[621] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[622] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[623] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[29]);
ros_msg[624] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[625] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[626] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[627] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[628] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[629] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[630] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[631] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[30]);
ros_msg[632] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[633] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[634] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[635] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[636] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[637] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[638] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[639] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[31]);
ros_msg[640] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[641] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[642] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[643] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[644] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[645] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[646] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[647] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[32]);
ros_msg[648] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[649] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[650] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[651] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[652] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[653] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[654] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[655] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[33]);
ros_msg[656] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[657] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[658] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[659] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[660] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[661] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[662] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[663] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[34]);
ros_msg[664] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[665] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[666] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[667] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[668] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[669] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[670] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[671] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[35]);
ros_msg[672] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[673] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[674] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[675] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[676] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[677] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[678] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[679] = (byte)((float64Long >> 0) & 0xffL);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(OdometryOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + OdometryOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(OdometryOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[588];
this.this_instruction=(Odometry)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.child_frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.child_frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[0]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[1]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[2]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[3]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[4]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[5]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[6]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[7]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[8]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[9]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[10]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[11]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[12]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[13]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[14]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[15]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[16]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[17]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[18]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[19]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[20]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[21]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[22]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[23]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[24]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[25]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[26]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[27]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[28]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[29]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[30]);
ros_msg[296] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[297] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[298] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[299] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[300] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[301] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[302] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[303] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[31]);
ros_msg[304] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[305] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[306] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[307] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[308] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[309] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[310] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[311] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[32]);
ros_msg[312] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[313] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[314] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[315] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[316] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[317] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[318] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[319] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[33]);
ros_msg[320] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[321] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[322] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[323] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[324] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[325] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[326] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[327] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[34]);
ros_msg[328] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[329] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[330] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[331] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[332] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[333] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[334] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[335] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[35]);
ros_msg[336] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[337] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[338] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[339] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[340] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[341] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[342] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[343] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.x);
ros_msg[344] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[345] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[346] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[347] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[348] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[349] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[350] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[351] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.y);
ros_msg[352] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[353] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[354] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[355] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[356] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[357] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[358] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[359] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.z);
ros_msg[360] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[361] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[362] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[363] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[364] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[365] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[366] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[367] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.x);
ros_msg[368] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[369] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[370] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[371] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[372] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[373] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[374] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[375] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.y);
ros_msg[376] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[377] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[378] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[379] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[380] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[381] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[382] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[383] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.z);
ros_msg[384] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[385] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[386] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[387] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[388] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[389] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[390] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[391] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[0]);
ros_msg[392] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[393] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[394] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[395] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[396] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[397] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[398] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[399] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[1]);
ros_msg[400] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[401] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[402] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[403] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[404] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[405] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[406] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[407] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[2]);
ros_msg[408] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[409] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[410] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[411] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[412] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[413] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[414] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[415] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[3]);
ros_msg[416] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[417] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[418] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[419] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[420] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[421] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[422] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[423] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[4]);
ros_msg[424] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[425] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[426] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[427] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[428] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[429] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[430] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[431] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[5]);
ros_msg[432] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[433] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[434] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[435] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[436] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[437] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[438] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[439] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[6]);
ros_msg[440] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[441] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[442] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[443] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[444] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[445] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[446] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[447] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[7]);
ros_msg[448] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[449] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[450] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[451] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[452] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[453] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[454] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[455] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[8]);
ros_msg[456] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[457] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[458] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[459] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[460] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[461] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[462] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[463] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[9]);
ros_msg[464] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[465] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[466] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[467] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[468] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[469] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[470] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[471] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[10]);
ros_msg[472] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[473] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[474] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[475] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[476] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[477] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[478] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[479] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[11]);
ros_msg[480] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[481] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[482] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[483] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[484] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[485] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[486] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[487] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[12]);
ros_msg[488] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[489] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[490] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[491] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[492] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[493] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[494] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[495] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[13]);
ros_msg[496] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[497] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[498] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[499] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[500] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[501] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[502] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[503] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[14]);
ros_msg[504] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[505] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[506] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[507] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[508] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[509] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[510] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[511] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[15]);
ros_msg[512] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[513] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[514] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[515] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[516] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[517] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[518] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[519] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[16]);
ros_msg[520] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[521] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[522] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[523] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[524] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[525] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[526] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[527] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[17]);
ros_msg[528] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[529] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[530] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[531] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[532] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[533] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[534] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[535] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[18]);
ros_msg[536] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[537] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[538] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[539] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[540] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[541] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[542] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[543] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[19]);
ros_msg[544] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[545] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[546] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[547] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[548] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[549] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[550] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[551] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[20]);
ros_msg[552] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[553] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[554] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[555] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[556] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[557] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[558] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[559] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[21]);
ros_msg[560] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[561] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[562] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[563] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[564] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[565] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[566] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[567] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[22]);
ros_msg[568] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[569] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[570] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[571] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[572] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[573] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[574] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[575] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[23]);
ros_msg[576] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[577] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[578] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[579] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[580] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[581] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[582] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[583] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[24]);
ros_msg[584] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[585] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[586] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[587] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[588] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[589] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[590] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[591] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[25]);
ros_msg[592] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[593] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[594] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[595] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[596] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[597] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[598] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[599] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[26]);
ros_msg[600] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[601] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[602] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[603] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[604] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[605] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[606] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[607] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[27]);
ros_msg[608] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[609] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[610] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[611] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[612] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[613] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[614] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[615] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[28]);
ros_msg[616] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[617] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[618] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[619] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[620] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[621] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[622] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[623] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[29]);
ros_msg[624] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[625] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[626] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[627] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[628] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[629] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[630] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[631] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[30]);
ros_msg[632] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[633] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[634] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[635] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[636] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[637] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[638] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[639] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[31]);
ros_msg[640] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[641] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[642] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[643] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[644] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[645] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[646] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[647] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[32]);
ros_msg[648] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[649] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[650] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[651] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[652] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[653] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[654] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[655] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[33]);
ros_msg[656] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[657] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[658] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[659] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[660] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[661] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[662] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[663] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[34]);
ros_msg[664] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[665] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[666] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[667] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[668] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[669] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[670] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[671] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[35]);
ros_msg[672] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[673] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[674] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[675] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[676] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[677] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[678] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[679] = (byte)((float64Long >> 0) & 0xffL);



    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(OdometryOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + OdometryOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(OdometryOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[588];
this.this_instruction=(Odometry)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.child_frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.child_frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[0]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[1]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[2]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[3]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[4]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[5]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[6]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[7]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[8]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[9]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
Aug 02, 2015 3:07:36 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[10]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[11]);
SEVERE: getFilePath(): null
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[12]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[13]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[14]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[15]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[16]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[17]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[18]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[19]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[20]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[21]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[22]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[23]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[24]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[25]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[26]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[27]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[28]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[29]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[30]);
ros_msg[296] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[297] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[298] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[299] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[300] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[301] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[302] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[303] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[31]);
ros_msg[304] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[305] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[306] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[307] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[308] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[309] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[310] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[311] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[32]);
ros_msg[312] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[313] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[314] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[315] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[316] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[317] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[318] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[319] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[33]);
ros_msg[320] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[321] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[322] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[323] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[324] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[325] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[326] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[327] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[34]);
ros_msg[328] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[329] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[330] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[331] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[332] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[333] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[334] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[335] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[35]);
ros_msg[336] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[337] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[338] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[339] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[340] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[341] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[342] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[343] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.x);
ros_msg[344] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[345] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[346] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[347] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[348] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[349] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[350] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[351] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.y);
ros_msg[352] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[353] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[354] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[355] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[356] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[357] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[358] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[359] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.linear.z);
ros_msg[360] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[361] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[362] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[363] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[364] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[365] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[366] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[367] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.x);
ros_msg[368] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[369] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[370] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[371] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[372] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[373] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[374] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[375] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.y);
ros_msg[376] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[377] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[378] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[379] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[380] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[381] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[382] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[383] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.twist.twist.angular.z);
ros_msg[384] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[385] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[386] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[387] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[388] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[389] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[390] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[391] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[0]);
ros_msg[392] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[393] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[394] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[395] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[396] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[397] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[398] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[399] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[1]);
ros_msg[400] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[401] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[402] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[403] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[404] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[405] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[406] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[407] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[2]);
ros_msg[408] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[409] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[410] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[411] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[412] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[413] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[414] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[415] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[3]);
ros_msg[416] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[417] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[418] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[419] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[420] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[421] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[422] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[423] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[4]);
ros_msg[424] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[425] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[426] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[427] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[428] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[429] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[430] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[431] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[5]);
ros_msg[432] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[433] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[434] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[435] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[436] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[437] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[438] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[439] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[6]);
ros_msg[440] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[441] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[442] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[443] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[444] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[445] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[446] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[447] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[7]);
ros_msg[448] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[449] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[450] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[451] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[452] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[453] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[454] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[455] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[8]);
ros_msg[456] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[457] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[458] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[459] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[460] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[461] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[462] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[463] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[9]);
ros_msg[464] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[465] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[466] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[467] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[468] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[469] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[470] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[471] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[10]);
ros_msg[472] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[473] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[474] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[475] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[476] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[477] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[478] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[479] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[11]);
ros_msg[480] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[481] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[482] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[483] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[484] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[485] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[486] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[487] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[12]);
ros_msg[488] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[489] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[490] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[491] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[492] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[493] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[494] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[495] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[13]);
ros_msg[496] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[497] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[498] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[499] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[500] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[501] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[502] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[503] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[14]);
ros_msg[504] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[505] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[506] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[507] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[508] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[509] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[510] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[511] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[15]);
ros_msg[512] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[513] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[514] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[515] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[516] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[517] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[518] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[519] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[16]);
ros_msg[520] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[521] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[522] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[523] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[524] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[525] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[526] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[527] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[17]);
ros_msg[528] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[529] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[530] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[531] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[532] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[533] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[534] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[535] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[18]);
ros_msg[536] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[537] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[538] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[539] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[540] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[541] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[542] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[543] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[19]);
ros_msg[544] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[545] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[546] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[547] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[548] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[549] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[550] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[551] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[20]);
ros_msg[552] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[553] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[554] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[555] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[556] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[557] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[558] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[559] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[21]);
ros_msg[560] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[561] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[562] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[563] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[564] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[565] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[566] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[567] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[22]);
ros_msg[568] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[569] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[570] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[571] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[572] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[573] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[574] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[575] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[23]);
ros_msg[576] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[577] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[578] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[579] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[580] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[581] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[582] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[583] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[24]);
ros_msg[584] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[585] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[586] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[587] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[588] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[589] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[590] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[591] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[25]);
ros_msg[592] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[593] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[594] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[595] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[596] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[597] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[598] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[599] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[26]);
ros_msg[600] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[601] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[602] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[603] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[604] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[605] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[606] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[607] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[27]);
ros_msg[608] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[609] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[610] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[611] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[612] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[613] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[614] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[615] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[28]);
ros_msg[616] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[617] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[618] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[619] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[620] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[621] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[622] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[623] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[29]);
ros_msg[624] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[625] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[626] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[627] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[628] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[629] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[630] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[631] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[30]);
ros_msg[632] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[633] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[634] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[635] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[636] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[637] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[638] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[639] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[31]);
ros_msg[640] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[641] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[642] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[643] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[644] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[645] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[646] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[647] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[32]);
ros_msg[648] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[649] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[650] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[651] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[652] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[653] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[654] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[655] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[33]);
ros_msg[656] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[657] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[658] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[659] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[660] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[661] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[662] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[663] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[34]);
ros_msg[664] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[665] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[666] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[667] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[668] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[669] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[670] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[671] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.twist.covariance[35]);
ros_msg[672] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[673] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[674] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[675] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[676] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[677] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[678] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[679] = (byte)((float64Long >> 0) & 0xffL);


        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            OdometryOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int array_length;
private long float64Long;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.LaserScan;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class LaserScanOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private LaserScanInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private LaserScan this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public LaserScanOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(LaserScanInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(4) +(4) +(4) +(4) +(4) +((this_instruction.ranges.length*4)+4) +((this_instruction.intensities.length*4)+4) ];
this.this_instruction=(LaserScan)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float32Int=Float.floatToRawIntBits(this_instruction.angle_min);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.angle_max);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.angle_increment);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.time_increment);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.scan_time);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.range_min);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.range_max);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.array_length=4*this_instruction.ranges.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.ranges.length;i++)
{
this.float32Int=Float.floatToRawIntBits(this_instruction.ranges[j]);
ros_msg[i] = (byte)((float32Int >> 24) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 8) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 0) & 0xff);
j=j+1;
}
current_position=current_position+(4*this_instruction.ranges.length);
this.array_length=4*this_instruction.intensities.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.intensities.length;i++)
{
this.float32Int=Float.floatToRawIntBits(this_instruction.intensities[j]);
ros_msg[i] = (byte)((float32Int >> 24) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 8) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 0) & 0xff);
j=j+1;
}
current_position=current_position+(4*this_instruction.intensities.length);
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(LaserScanOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + LaserScanOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(LaserScanOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(4) +(4) +(4) +(4) +(4) +((this_instruction.ranges.length*4)+4) +((this_instruction.intensities.length*4)+4) ];
this.this_instruction=(LaserScan)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float32Int=Float.floatToRawIntBits(this_instruction.angle_min);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.angle_max);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.angle_increment);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.time_increment);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.scan_time);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.range_min);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.range_max);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.array_length=4*this_instruction.ranges.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.ranges.length;i++)
{
this.float32Int=Float.floatToRawIntBits(this_instruction.ranges[j]);
ros_msg[i] = (byte)((float32Int >> 24) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 8) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 0) & 0xff);
j=j+1;
}
current_position=current_position+(4*this_instruction.ranges.length);
this.array_length=4*this_instruction.intensities.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.intensities.length;i++)
{
this.float32Int=Float.floatToRawIntBits(this_instruction.intensities[j]);
ros_msg[i] = (byte)((float32Int >> 24) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 8) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 0) & 0xff);
j=j+1;
}
current_position=current_position+(4*this_instruction.intensities.length);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(LaserScanOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + LaserScanOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(LaserScanOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(4) +(4) +(4) +(4) +(4) +((this_instruction.ranges.length*4)+4) +((this_instruction.intensities.length*4)+4) ];
this.this_instruction=(LaserScan)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float32Int=Float.floatToRawIntBits(this_instruction.angle_min);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.angle_max);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.angle_increment);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.time_increment);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.scan_time);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.range_min);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.float32Int=Float.floatToRawIntBits(this_instruction.range_max);
ros_msg[current_position] = (byte)((float32Int >> 24) & 0xff);
ros_msg[current_position+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[current_position+2] = (byte)((float32Int >> 8) & 0xff);
ros_msg[current_position+3] = (byte)((float32Int >> 0) & 0xff);
current_position = current_position + 4;this.array_length=4*this_instruction.ranges.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.ranges.length;i++)
{
this.float32Int=Float.floatToRawIntBits(this_instruction.ranges[j]);
ros_msg[i] = (byte)((float32Int >> 24) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 8) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 0) & 0xff);
j=j+1;
}
current_position=current_position+(4*this_instruction.ranges.length);
this.array_length=4*this_instruction.intensities.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.intensities.length;i++)
{
this.float32Int=Float.floatToRawIntBits(this_instruction.intensities[j]);
ros_msg[i] = (byte)((float32Int >> 24) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 16) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 8) & 0xff);
ros_msg[i=i+1] = (byte)((float32Int >> 0) & 0xff);
j=j+1;
}
current_position=current_position+(4*this_instruction.intensities.length);
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            LaserScanOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
    private java.lang.String str;
private int array_length;
    private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int float32Int;
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }    private int soup;
    private long seq=0;
    private int y;
}


VARIABLE: string
OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.CameraInfo;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class CameraInfoOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private CameraInfoInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private CameraInfo this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public CameraInfoOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(CameraInfoInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[ + 16+12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.distortion_model.length()+1)/2)+4) +((this_instruction.D.length*8)+4) +((this_instruction.K.length*8)+4) +((this_instruction.R.length*8)+4) +((this_instruction.P.length*8)+4) +(4) +(4) +4+4+4+4+1];
this.this_instruction=(CameraInfo)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.distortion_model.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.distortion_model);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.array_length=8*this_instruction.D.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.D.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.D[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.D.length);
this.array_length=8*this_instruction.K.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.K.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.K[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.K.length);
this.array_length=8*this_instruction.R.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.R.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.R[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.R.length);
this.array_length=8*this_instruction.P.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.P.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.P[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.P.length);
ros_msg[current_position] = (byte)((this_instruction.binning_x >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_x >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_x >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_x >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.binning_y >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_y >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_y >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_y >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[240] = (byte)((this_instruction.roi.x_offset >>> 24) & 0xff);
ros_msg[241] = (byte)((this_instruction.roi.x_offset >>> 16) & 0xff);
ros_msg[242] = (byte)((this_instruction.roi.x_offset >>> 8) & 0xff);
ros_msg[243] = (byte)((this_instruction.roi.x_offset >>> 0) & 0xff);

ros_msg[244] = (byte)((this_instruction.roi.y_offset >>> 24) & 0xff);
ros_msg[245] = (byte)((this_instruction.roi.y_offset >>> 16) & 0xff);
ros_msg[246] = (byte)((this_instruction.roi.y_offset >>> 8) & 0xff);
ros_msg[247] = (byte)((this_instruction.roi.y_offset >>> 0) & 0xff);

ros_msg[248] = (byte)((this_instruction.roi.height >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.roi.height >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.roi.height >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.roi.height >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.roi.width >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.roi.width >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.roi.width >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.roi.width >>> 0) & 0xff);

ros_msg[256]=(byte)(((short)(this_instruction.roi.do_rectify?1:0) >>> 0) & 0xff);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + CameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[ + 16+12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.distortion_model.length()+1)/2)+4) +((this_instruction.D.length*8)+4) +((this_instruction.K.length*8)+4) +((this_instruction.R.length*8)+4) +((this_instruction.P.length*8)+4) +(4) +(4) +4+4+4+4+1];
this.this_instruction=(CameraInfo)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.distortion_model.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.distortion_model);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.array_length=8*this_instruction.D.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.D.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.D[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.D.length);
this.array_length=8*this_instruction.K.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.K.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.K[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.K.length);
this.array_length=8*this_instruction.R.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.R.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.R[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.R.length);
this.array_length=8*this_instruction.P.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.P.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.P[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.P.length);
ros_msg[current_position] = (byte)((this_instruction.binning_x >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_x >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_x >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_x >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.binning_y >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_y >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_y >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_y >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[240] = (byte)((this_instruction.roi.x_offset >>> 24) & 0xff);
ros_msg[241] = (byte)((this_instruction.roi.x_offset >>> 16) & 0xff);
ros_msg[242] = (byte)((this_instruction.roi.x_offset >>> 8) & 0xff);
ros_msg[243] = (byte)((this_instruction.roi.x_offset >>> 0) & 0xff);

ros_msg[244] = (byte)((this_instruction.roi.y_offset >>> 24) & 0xff);
ros_msg[245] = (byte)((this_instruction.roi.y_offset >>> 16) & 0xff);
ros_msg[246] = (byte)((this_instruction.roi.y_offset >>> 8) & 0xff);
ros_msg[247] = (byte)((this_instruction.roi.y_offset >>> 0) & 0xff);

ros_msg[248] = (byte)((this_instruction.roi.height >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.roi.height >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.roi.height >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.roi.height >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.roi.width >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.roi.width >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.roi.width >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.roi.width >>> 0) & 0xff);

ros_msg[256]=(byte)(((short)(this_instruction.roi.do_rectify?1:0) >>> 0) & 0xff);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + CameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[ + 16+12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.distortion_model.length()+1)/2)+4) +((this_instruction.D.length*8)+4) +((this_instruction.K.length*8)+4) +((this_instruction.R.length*8)+4) +((this_instruction.P.length*8)+4) +(4) +(4) +4+4+4+4+1];
this.this_instruction=(CameraInfo)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.distortion_model.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.distortion_model);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.array_length=8*this_instruction.D.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.D.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.D[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.D.length);
this.array_length=8*this_instruction.K.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.K.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.K[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.K.length);
this.array_length=8*this_instruction.R.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.R.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.R[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.R.length);
this.array_length=8*this_instruction.P.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.P.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.P[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.P.length);
ros_msg[current_position] = (byte)((this_instruction.binning_x >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_x >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_x >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_x >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.binning_y >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_y >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_y >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_y >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[240] = (byte)((this_instruction.roi.x_offset >>> 24) & 0xff);
ros_msg[241] = (byte)((this_instruction.roi.x_offset >>> 16) & 0xff);
ros_msg[242] = (byte)((this_instruction.roi.x_offset >>> 8) & 0xff);
ros_msg[243] = (byte)((this_instruction.roi.x_offset >>> 0) & 0xff);

ros_msg[244] = (byte)((this_instruction.roi.y_offset >>> 24) & 0xff);
ros_msg[245] = (byte)((this_instruction.roi.y_offset >>> 16) & 0xff);
ros_msg[246] = (byte)((this_instruction.roi.y_offset >>> 8) & 0xff);
ros_msg[247] = (byte)((this_instruction.roi.y_offset >>> 0) & 0xff);

ros_msg[248] = (byte)((this_instruction.roi.height >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.roi.height >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.roi.height >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.roi.height >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.roi.width >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.roi.width >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.roi.width >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.roi.width >>> 0) & 0xff);

ros_msg[256]=(byte)(((short)(this_instruction.roi.do_rectify?1:0) >>> 0) & 0xff);

        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            CameraInfoOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int array_length;
private long float64Long;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.PointCloud2;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class PointCloud2OutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private PointCloud2InstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private PointCloud2 this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public PointCloud2OutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(PointCloud2InstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(1) +(4) +(4) +((this_instruction.data.length*1)+4) +(1) ];
this.this_instruction=(PointCloud2)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position]=(byte)(((short)(this_instruction.is_bigendian?1:0) >>> 0) & 0xff);current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.point_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.point_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.point_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.point_step >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.row_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.row_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.row_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.row_step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
ros_msg[current_position]=(byte)(((short)(this_instruction.is_dense?1:0) >>> 0) & 0xff);current_position = current_position + 1;    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PointCloud2OutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(1) +(4) +(4) +((this_instruction.data.length*1)+4) +(1) ];
this.this_instruction=(PointCloud2)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position]=(byte)(((short)(this_instruction.is_bigendian?1:0) >>> 0) & 0xff);current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.point_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.point_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.point_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.point_step >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.row_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.row_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.row_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.row_step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
ros_msg[current_position]=(byte)(((short)(this_instruction.is_dense?1:0) >>> 0) & 0xff);current_position = current_position + 1;
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PointCloud2OutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(1) +(4) +(4) +((this_instruction.data.length*1)+4) +(1) ];
this.this_instruction=(PointCloud2)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position]=(byte)(((short)(this_instruction.is_bigendian?1:0) >>> 0) & 0xff);current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.point_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.point_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.point_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.point_step >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.row_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.row_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.row_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.row_step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
ros_msg[current_position]=(byte)(((short)(this_instruction.is_dense?1:0) >>> 0) & 0xff);current_position = current_position + 1;        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            PointCloud2OutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
    private java.lang.String str;
private int array_length;
private byte int8Byte;
    private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }    private int soup;
    private long seq=0;
    private int y;
}


OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.Imu;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class ImuOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private ImuInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Imu this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public ImuOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(ImuInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[312];
this.this_instruction=(Imu)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.orientation.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.w);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[0]);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[1]);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[2]);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[3]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[4]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[5]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[6]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[7]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[8]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.x);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.y);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.z);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[0]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[1]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[2]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[3]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[4]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[5]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[6]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[7]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[8]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.x);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.y);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.z);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[0]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[1]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[2]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[3]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[4]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[5]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[6]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[7]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[8]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ImuOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ImuOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ImuOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[312];
this.this_instruction=(Imu)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.orientation.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.w);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[0]);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[1]);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[2]);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[3]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[4]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[5]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[6]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[7]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[8]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.x);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.y);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.z);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[0]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[1]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[2]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[3]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[4]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[5]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[6]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[7]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[8]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.x);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.y);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.z);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[0]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[1]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[2]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[3]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[4]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[5]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[6]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[7]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[8]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ImuOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ImuOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ImuOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[312];
this.this_instruction=(Imu)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.orientation.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.orientation.w);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[0]);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[1]);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[2]);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[3]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[4]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[5]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[6]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[7]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.orientation_covariance[8]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.x);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.y);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity.z);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[0]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[1]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[2]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[3]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[4]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[5]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[6]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[7]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.angular_velocity_covariance[8]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.x);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.y);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration.z);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[0]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[1]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[2]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[3]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[4]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[5]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[6]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
Aug 02, 2015 3:07:53 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[7]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
Aug 02, 2015 3:07:53 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
SEVERE: getFilePath(): null
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.linear_acceleration_covariance[8]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);

        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            ImuOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
    private java.lang.String str;
private int array_length;
private long float64Long;
    private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }    private int soup;
    private long seq=0;
    private int y;
}


OutputHandler:
package ros.geometry_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.geometry_msgs.Twist;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class TwistOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private TwistInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Twist this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public TwistOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(TwistInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);



    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + TwistOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(TwistOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[52];
this.this_instruction=(Twist)instruction;
this.float64Long=Double.doubleToLongBits(this_instruction.linear.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
Aug 02, 2015 3:07:54 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

Aug 02, 2015 3:07:54 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
this.float64Long=Double.doubleToLongBits(this_instruction.linear.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
SEVERE: getFilePath(): null
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.linear.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.angular.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.angular.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);


        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            TwistOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private long float64Long;
}


VARIABLE: string
OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.CameraInfo;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class CameraInfoOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private CameraInfoInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private CameraInfo this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public CameraInfoOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(CameraInfoInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[ + 16+12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.distortion_model.length()+1)/2)+4) +((this_instruction.D.length*8)+4) +((this_instruction.K.length*8)+4) +((this_instruction.R.length*8)+4) +((this_instruction.P.length*8)+4) +(4) +(4) +4+4+4+4+1];
this.this_instruction=(CameraInfo)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.distortion_model.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.distortion_model);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.array_length=8*this_instruction.D.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.D.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.D[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.D.length);
this.array_length=8*this_instruction.K.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.K.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.K[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.K.length);
this.array_length=8*this_instruction.R.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.R.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.R[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.R.length);
this.array_length=8*this_instruction.P.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.P.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.P[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.P.length);
ros_msg[current_position] = (byte)((this_instruction.binning_x >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_x >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_x >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_x >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.binning_y >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_y >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_y >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_y >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[240] = (byte)((this_instruction.roi.x_offset >>> 24) & 0xff);
ros_msg[241] = (byte)((this_instruction.roi.x_offset >>> 16) & 0xff);
ros_msg[242] = (byte)((this_instruction.roi.x_offset >>> 8) & 0xff);
ros_msg[243] = (byte)((this_instruction.roi.x_offset >>> 0) & 0xff);

ros_msg[244] = (byte)((this_instruction.roi.y_offset >>> 24) & 0xff);
ros_msg[245] = (byte)((this_instruction.roi.y_offset >>> 16) & 0xff);
ros_msg[246] = (byte)((this_instruction.roi.y_offset >>> 8) & 0xff);
ros_msg[247] = (byte)((this_instruction.roi.y_offset >>> 0) & 0xff);

ros_msg[248] = (byte)((this_instruction.roi.height >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.roi.height >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.roi.height >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.roi.height >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.roi.width >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.roi.width >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.roi.width >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.roi.width >>> 0) & 0xff);

ros_msg[256]=(byte)(((short)(this_instruction.roi.do_rectify?1:0) >>> 0) & 0xff);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + CameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[ + 16+12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.distortion_model.length()+1)/2)+4) +((this_instruction.D.length*8)+4) +((this_instruction.K.length*8)+4) +((this_instruction.R.length*8)+4) +((this_instruction.P.length*8)+4) +(4) +(4) +4+4+4+4+1];
this.this_instruction=(CameraInfo)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.distortion_model.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.distortion_model);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.array_length=8*this_instruction.D.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.D.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.D[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.D.length);
this.array_length=8*this_instruction.K.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.K.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.K[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.K.length);
this.array_length=8*this_instruction.R.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.R.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.R[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.R.length);
this.array_length=8*this_instruction.P.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.P.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.P[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.P.length);
ros_msg[current_position] = (byte)((this_instruction.binning_x >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_x >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_x >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_x >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.binning_y >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_y >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_y >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_y >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[240] = (byte)((this_instruction.roi.x_offset >>> 24) & 0xff);
ros_msg[241] = (byte)((this_instruction.roi.x_offset >>> 16) & 0xff);
ros_msg[242] = (byte)((this_instruction.roi.x_offset >>> 8) & 0xff);
ros_msg[243] = (byte)((this_instruction.roi.x_offset >>> 0) & 0xff);

ros_msg[244] = (byte)((this_instruction.roi.y_offset >>> 24) & 0xff);
ros_msg[245] = (byte)((this_instruction.roi.y_offset >>> 16) & 0xff);
ros_msg[246] = (byte)((this_instruction.roi.y_offset >>> 8) & 0xff);
ros_msg[247] = (byte)((this_instruction.roi.y_offset >>> 0) & 0xff);

ros_msg[248] = (byte)((this_instruction.roi.height >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.roi.height >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.roi.height >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.roi.height >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.roi.width >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.roi.width >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.roi.width >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.roi.width >>> 0) & 0xff);

ros_msg[256]=(byte)(((short)(this_instruction.roi.do_rectify?1:0) >>> 0) & 0xff);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + CameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(CameraInfoOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[ + 16+12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.distortion_model.length()+1)/2)+4) +((this_instruction.D.length*8)+4) +((this_instruction.K.length*8)+4) +((this_instruction.R.length*8)+4) +((this_instruction.P.length*8)+4) +(4) +(4) +4+4+4+4+1];
this.this_instruction=(CameraInfo)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.distortion_model.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.distortion_model);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.array_length=8*this_instruction.D.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.D.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.D[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.D.length);
this.array_length=8*this_instruction.K.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.K.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.K[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.K.length);
this.array_length=8*this_instruction.R.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.R.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.R[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.R.length);
this.array_length=8*this_instruction.P.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.P.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.P[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.P.length);
ros_msg[current_position] = (byte)((this_instruction.binning_x >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_x >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_x >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_x >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.binning_y >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.binning_y >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.binning_y >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.binning_y >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[240] = (byte)((this_instruction.roi.x_offset >>> 24) & 0xff);
ros_msg[241] = (byte)((this_instruction.roi.x_offset >>> 16) & 0xff);
ros_msg[242] = (byte)((this_instruction.roi.x_offset >>> 8) & 0xff);
ros_msg[243] = (byte)((this_instruction.roi.x_offset >>> 0) & 0xff);

ros_msg[244] = (byte)((this_instruction.roi.y_offset >>> 24) & 0xff);
ros_msg[245] = (byte)((this_instruction.roi.y_offset >>> 16) & 0xff);
ros_msg[246] = (byte)((this_instruction.roi.y_offset >>> 8) & 0xff);
ros_msg[247] = (byte)((this_instruction.roi.y_offset >>> 0) & 0xff);

ros_msg[248] = (byte)((this_instruction.roi.height >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.roi.height >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.roi.height >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.roi.height >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.roi.width >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.roi.width >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.roi.width >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.roi.width >>> 0) & 0xff);

ros_msg[256]=(byte)(((short)(this_instruction.roi.do_rectify?1:0) >>> 0) & 0xff);

        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            CameraInfoOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int array_length;
private long float64Long;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


OutputHandler:
package ros.std_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.std_msgs.String;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class StringOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private StringInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private String this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public StringOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(StringInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(String)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.data.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.data);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(StringOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + StringOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(StringOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(String)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.data.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.data);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(StringOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + StringOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(StringOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(String)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.data.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.data);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            StringOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.JointState;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class JointStateOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private JointStateInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private JointState this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public JointStateOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(JointStateInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.name)+4)) +((this_instruction.position.length*8)+4) +((this_instruction.velocity.length*8)+4) +((this_instruction.effort.length*8)+4) ];
this.this_instruction=(JointState)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.name.length)
{
arrays_length=arrays_length + ((this_instruction.name[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.name.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.name.length)
{
    this.string_length=(this_instruction.name[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;
this.array_length=8*this_instruction.position.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.position.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.position[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.position.length);
this.array_length=8*this_instruction.velocity.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.velocity.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.velocity[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.velocity.length);
this.array_length=8*this_instruction.effort.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.effort.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.effort[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.effort.length);
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(JointStateOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + JointStateOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(JointStateOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.name)+4)) +((this_instruction.position.length*8)+4) +((this_instruction.velocity.length*8)+4) +((this_instruction.effort.length*8)+4) ];
this.this_instruction=(JointState)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.name.length)
{
arrays_length=arrays_length + ((this_instruction.name[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.name.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.name.length)
{
    this.string_length=(this_instruction.name[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;
this.array_length=8*this_instruction.position.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.position.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.position[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.position.length);
this.array_length=8*this_instruction.velocity.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.velocity.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.velocity[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.velocity.length);
this.array_length=8*this_instruction.effort.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.effort.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.effort[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.effort.length);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(JointStateOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + JointStateOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(JointStateOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.name)+4)) +((this_instruction.position.length*8)+4) +((this_instruction.velocity.length*8)+4) +((this_instruction.effort.length*8)+4) ];
this.this_instruction=(JointState)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.name.length)
{
arrays_length=arrays_length + ((this_instruction.name[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.name.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.name.length)
{
    this.string_length=(this_instruction.name[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;
this.array_length=8*this_instruction.position.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.position.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.position[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.position.length);
this.array_length=8*this_instruction.velocity.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.velocity.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.velocity[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.velocity.length);
this.array_length=8*this_instruction.effort.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.effort.length;i++)
{
this.float64Long=Double.doubleToLongBits(this_instruction.effort[j]);
ros_msg[i] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[i=i+1] = (byte)((float64Long >> 0) & 0xffL);
j=j+1;
}
current_position=current_position+(8*this_instruction.effort.length);
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            JointStateOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int str_i;
private int array_length;
private long float64Long;
private int arrays_length;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


VARIABLE: string
VARIABLE: string
VARIABLE: string
VARIABLE: string
OutputHandler:
package ros.rosgraph_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.rosgraph_msgs.Log;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class LogOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private LogInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Log this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public LogOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(LogInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(1) +(((this_instruction.name.length()+1)/2)+4) +(((this_instruction.msg.length()+1)/2)+4) +(((this_instruction.file.length()+1)/2)+4) +(((this_instruction.function.length()+1)/2)+4) +(4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.topics)+4)) ];
this.this_instruction=(Log)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.level >> 0));
current_position = current_position + 1;this.string_length=(this_instruction.name.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.msg.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.msg);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.file.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.file);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.function.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.function);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.line >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.line >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.line >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.line >>> 0) & 0xff);
current_position = current_position + 4;arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.topics.length)
{
arrays_length=arrays_length + ((this_instruction.topics[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.topics.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.topics.length)
{
    this.string_length=(this_instruction.topics[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.topics[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + LogOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(1) +(((this_instruction.name.length()+1)/2)+4) +(((this_instruction.msg.length()+1)/2)+4) +(((this_instruction.file.length()+1)/2)+4) +(((this_instruction.function.length()+1)/2)+4) +(4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.topics)+4)) ];
this.this_instruction=(Log)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.level >> 0));
current_position = current_position + 1;this.string_length=(this_instruction.name.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.msg.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.msg);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.file.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.file);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.function.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.function);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.line >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.line >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.line >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.line >>> 0) & 0xff);
current_position = current_position + 4;arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.topics.length)
{
arrays_length=arrays_length + ((this_instruction.topics[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.topics.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.topics.length)
{
    this.string_length=(this_instruction.topics[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.topics[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + LogOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(1) +(((this_instruction.name.length()+1)/2)+4) +(((this_instruction.msg.length()+1)/2)+4) +(((this_instruction.file.length()+1)/2)+4) +(((this_instruction.function.length()+1)/2)+4) +(4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.topics)+4)) ];
this.this_instruction=(Log)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.level >> 0));
current_position = current_position + 1;this.string_length=(this_instruction.name.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.msg.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.msg);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.file.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.file);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.function.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.function);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.line >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.line >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.line >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.line >>> 0) & 0xff);
current_position = current_position + 4;arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.topics.length)
{
arrays_length=arrays_length + ((this_instruction.topics[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.topics.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.topics.length)
{
    this.string_length=(this_instruction.topics[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.topics[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            LogOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int str_i;
private int array_length;
private int arrays_length;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


VARIABLE: string
OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.Image;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class ImageOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private ImageInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Image this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public ImageOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(ImageInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.encoding.length()+1)/2)+4) +(1) +(4) +((this_instruction.data.length*1)+4) ];
this.this_instruction=(Image)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.encoding.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
Aug 02, 2015 3:08:03 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
{
Aug 02, 2015 3:08:03 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
this.str=hexStringConverter.stringToHex(this_instruction.encoding);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
Aug 02, 2015 3:08:03 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
Aug 02, 2015 3:08:03 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
        if ((soup % 2) == 0) 
        {
SEVERE: getFilePath(): null
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
Aug 02, 2015 3:08:03 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
SEVERE: getFilePath(): null
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.is_bigendian >>> 0) & 0xff);
current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ImageOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.encoding.length()+1)/2)+4) +(1) +(4) +((this_instruction.data.length*1)+4) ];
this.this_instruction=(Image)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.encoding.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.encoding);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
Aug 02, 2015 3:08:04 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
Aug 02, 2015 3:08:04 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.is_bigendian >>> 0) & 0xff);
current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ImageOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ImageOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(((this_instruction.encoding.length()+1)/2)+4) +(1) +(4) +((this_instruction.data.length*1)+4) ];
this.this_instruction=(Image)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;this.string_length=(this_instruction.encoding.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.encoding);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.is_bigendian >>> 0) & 0xff);
current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            ImageOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int array_length;
private byte int8Byte;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


VARIABLE: string
VARIABLE: string
VARIABLE: string
VARIABLE: string
OutputHandler:
package ros.rosgraph_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.rosgraph_msgs.Log;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class LogOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private LogInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Log this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public LogOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(LogInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(1) +(((this_instruction.name.length()+1)/2)+4) +(((this_instruction.msg.length()+1)/2)+4) +(((this_instruction.file.length()+1)/2)+4) +(((this_instruction.function.length()+1)/2)+4) +(4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.topics)+4)) ];
this.this_instruction=(Log)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.level >> 0));
current_position = current_position + 1;this.string_length=(this_instruction.name.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.msg.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.msg);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.file.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.file);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.function.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.function);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.line >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.line >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.line >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.line >>> 0) & 0xff);
current_position = current_position + 4;arrays_length=0;
this.str_i=0;
Aug 02, 2015 3:08:05 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
while(str_i<this_instruction.topics.length)
{
arrays_length=arrays_length + ((this_instruction.topics[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.topics.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.topics.length)
{
    this.string_length=(this_instruction.topics[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.topics[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + LogOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(1) +(((this_instruction.name.length()+1)/2)+4) +(((this_instruction.msg.length()+1)/2)+4) +(((this_instruction.file.length()+1)/2)+4) +(((this_instruction.function.length()+1)/2)+4) +(4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.topics)+4)) ];
this.this_instruction=(Log)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.level >> 0));
current_position = current_position + 1;this.string_length=(this_instruction.name.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.msg.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.msg);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.file.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.file);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.function.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.function);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.line >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.line >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.line >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.line >>> 0) & 0xff);
current_position = current_position + 4;arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.topics.length)
{
arrays_length=arrays_length + ((this_instruction.topics[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.topics.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.topics.length)
{
    this.string_length=(this_instruction.topics[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.topics[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + LogOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(LogOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(1) +(((this_instruction.name.length()+1)/2)+4) +(((this_instruction.msg.length()+1)/2)+4) +(((this_instruction.file.length()+1)/2)+4) +(((this_instruction.function.length()+1)/2)+4) +(4) +((ROSMessageDefinitionTypeConverter.getStringArrayToBytesLength(this_instruction.topics)+4)) ];
this.this_instruction=(Log)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.level >> 0));
current_position = current_position + 1;this.string_length=(this_instruction.name.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.name);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.msg.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.msg);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.file.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.file);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.function.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.function);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.line >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.line >>> 16) & 0xff);
Aug 02, 2015 3:08:07 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
ros_msg[current_position+2] = (byte)((this_instruction.line >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.line >>> 0) & 0xff);
current_position = current_position + 4;arrays_length=0;
this.str_i=0;
while(str_i<this_instruction.topics.length)
{
arrays_length=arrays_length + ((this_instruction.topics[str_i].length()+1)/2);
this.str_i=str_i+1;
}
//  Set the array_length for the variable array prefix - arrays.length + prefix length is (String[].length*4)=ROS Fixed String[]length
this.array_length=arrays_length + (this_instruction.topics.length*4);
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
this.str_i=0;
try
{
while(str_i<this_instruction.topics.length)
{
    this.string_length=(this_instruction.topics[str_i].length()+1)/2;
    ros_msg[current_position+3] = (byte)((string_length >>> 24) & 0xff);
    ros_msg[current_position+2] = (byte)((string_length >>> 16) & 0xff);
    ros_msg[current_position+1] = (byte)((string_length >>> 8) & 0xff);
    ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
    // increment the current_position to the first array byte index past the 
    current_position=current_position + 4;

      try
{
this.str=hexStringConverter.stringToHex(this_instruction.topics[str_i]);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }

    // Set the current position
    current_position=current_position+string_length;
    this.str_i=str_i+1;
}
}
catch(Exception e)
{
e.printStackTrace();
}
current_position=current_position+array_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            LogOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int str_i;
private int array_length;
private int arrays_length;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


OutputHandler:
package ros.rosgraph_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.rosgraph_msgs.Clock;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class ClockOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private ClockInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Clock this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public ClockOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(ClockInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
Aug 02, 2015 3:08:07 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
SEVERE: getFilePath(): null
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12];
this.this_instruction=(Clock)instruction;
ros_msg[0] = (byte)((this_instruction.clock.secs >>> 24) & 0xff);
ros_msg[1] = (byte)((this_instruction.clock.secs >>> 16) & 0xff);
ros_msg[2] = (byte)((this_instruction.clock.secs >>> 8) & 0xff);
ros_msg[3] = (byte)((this_instruction.clock.secs >>> 0) & 0xff);
ros_msg[4] = (byte)((this_instruction.clock.nsecs >>> 24) & 0xff);
ros_msg[5] = (byte)((this_instruction.clock.nsecs >>> 16) & 0xff);
ros_msg[6] = (byte)((this_instruction.clock.nsecs >>> 8) & 0xff);
ros_msg[7] = (byte)((this_instruction.clock.nsecs >>> 0) & 0xff);

    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ClockOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ClockOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ClockOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12];
this.this_instruction=(Clock)instruction;
ros_msg[0] = (byte)((this_instruction.clock.secs >>> 24) & 0xff);
ros_msg[1] = (byte)((this_instruction.clock.secs >>> 16) & 0xff);
ros_msg[2] = (byte)((this_instruction.clock.secs >>> 8) & 0xff);
ros_msg[3] = (byte)((this_instruction.clock.secs >>> 0) & 0xff);
ros_msg[4] = (byte)((this_instruction.clock.nsecs >>> 24) & 0xff);
ros_msg[5] = (byte)((this_instruction.clock.nsecs >>> 16) & 0xff);
ros_msg[6] = (byte)((this_instruction.clock.nsecs >>> 8) & 0xff);
ros_msg[7] = (byte)((this_instruction.clock.nsecs >>> 0) & 0xff);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(ClockOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + ClockOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(ClockOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12];
this.this_instruction=(Clock)instruction;
ros_msg[0] = (byte)((this_instruction.clock.secs >>> 24) & 0xff);
ros_msg[1] = (byte)((this_instruction.clock.secs >>> 16) & 0xff);
ros_msg[2] = (byte)((this_instruction.clock.secs >>> 8) & 0xff);
ros_msg[3] = (byte)((this_instruction.clock.secs >>> 0) & 0xff);
ros_msg[4] = (byte)((this_instruction.clock.nsecs >>> 24) & 0xff);
ros_msg[5] = (byte)((this_instruction.clock.nsecs >>> 16) & 0xff);
ros_msg[6] = (byte)((this_instruction.clock.nsecs >>> 8) & 0xff);
ros_msg[7] = (byte)((this_instruction.clock.nsecs >>> 0) & 0xff);

        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            ClockOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.PointCloud2;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class PointCloud2OutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private PointCloud2InstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private PointCloud2 this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public PointCloud2OutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(PointCloud2InstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(1) +(4) +(4) +((this_instruction.data.length*1)+4) +(1) ];
this.this_instruction=(PointCloud2)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position]=(byte)(((short)(this_instruction.is_bigendian?1:0) >>> 0) & 0xff);current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.point_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.point_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.point_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.point_step >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.row_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.row_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.row_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.row_step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
Aug 02, 2015 3:08:08 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
ros_msg[current_position]=(byte)(((short)(this_instruction.is_dense?1:0) >>> 0) & 0xff);current_position = current_position + 1;    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PointCloud2OutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(1) +(4) +(4) +((this_instruction.data.length*1)+4) +(1) ];
this.this_instruction=(PointCloud2)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position]=(byte)(((short)(this_instruction.is_bigendian?1:0) >>> 0) & 0xff);current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.point_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.point_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.point_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.point_step >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.row_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.row_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.row_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.row_step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
ros_msg[current_position]=(byte)(((short)(this_instruction.is_dense?1:0) >>> 0) & 0xff);current_position = current_position + 1;
    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PointCloud2OutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PointCloud2OutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

Aug 02, 2015 3:08:09 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[12+(((this_instruction.header.frame_id.length()+1)/2)+4) +(4) +(4) +(1) +(4) +(4) +((this_instruction.data.length*1)+4) +(1) ];
SEVERE: getFilePath(): null
this.this_instruction=(PointCloud2)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
Aug 02, 2015 3:08:09 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
ros_msg[current_position] = (byte)((this_instruction.height >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.height >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.height >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.height >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.width >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.width >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.width >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.width >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position]=(byte)(((short)(this_instruction.is_bigendian?1:0) >>> 0) & 0xff);current_position = current_position + 1;ros_msg[current_position] = (byte)((this_instruction.point_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.point_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.point_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.point_step >>> 0) & 0xff);
current_position = current_position + 4;ros_msg[current_position] = (byte)((this_instruction.row_step >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.row_step >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.row_step >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.row_step >>> 0) & 0xff);
current_position = current_position + 4;this.array_length=this_instruction.data.length;
ros_msg[current_position=current_position+3] = (byte)((array_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((array_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((array_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((array_length >>> 0) & 0xff);
current_position=current_position+1;
j=0;
for(int i=current_position;i<this_instruction.data.length;i++)
{
this.int8Byte=this_instruction.data[j];
ros_msg[i] = (byte)((int8Byte >> 0));
j=j+1;
}
current_position=current_position+(this_instruction.data.length);
ros_msg[current_position]=(byte)(((short)(this_instruction.is_dense?1:0) >>> 0) & 0xff);current_position = current_position + 1;        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            PointCloud2OutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
    private java.lang.String str;
private int array_length;
private byte int8Byte;
    private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }    private int soup;
    private long seq=0;
    private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
Aug 02, 2015 3:08:11 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
Aug 02, 2015 3:08:12 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
SEVERE: getFilePath(): null
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
Aug 02, 2015 3:08:13 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.std_srvs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.std_srvs.Empty;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class EmptyOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private EmptyInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Empty this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public EmptyOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(EmptyInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
Aug 02, 2015 3:08:14 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            EmptyOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
Aug 02, 2015 3:08:15 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
Aug 02, 2015 3:08:16 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
SEVERE: getFilePath(): null
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.std_srvs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.std_srvs.Empty;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class EmptyOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private EmptyInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Empty this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public EmptyOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(EmptyInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            EmptyOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
Aug 02, 2015 3:08:21 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
Aug 02, 2015 3:08:21 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
                } 
                catch (IOException exc) 
                {
Aug 02, 2015 3:08:21 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
SEVERE: getFilePath(): null
                }                
            }
          } 
          catch (Exception ex) 
          {
Aug 02, 2015 3:08:21 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
SEVERE: getFilePath(): null
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
SEVERE: getFilePath(): null
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
SEVERE: getFilePath(): null
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
SEVERE: getFilePath(): null
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
SEVERE: getFilePath(): null
      while (y < (current_position+str.length())) 
      {
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
SEVERE: getFilePath(): null
        soup=soup+1;
        y=y+1;
      }
      }
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
current_position=current_position+string_length;
        return ros_msg;
    }

SEVERE: getFilePath(): null
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
Aug 02, 2015 3:08:22 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
SEVERE: getFilePath(): null
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.std_srvs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.std_srvs.Empty;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class EmptyOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private EmptyInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Empty this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public EmptyOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(EmptyInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            EmptyOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


OutputHandler:
package ros.std_srvs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.std_srvs.Empty;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class EmptyOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private EmptyInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private Empty this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public EmptyOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(EmptyInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + EmptyOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(EmptyOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(Empty)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            EmptyOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/sensor_msgs/regionofinterest, Schema File: # This message is used to specify a region of interest within an image.
#
# When used to specify the ROI setting of the camera when the image was
# taken, the height and width fields should either match the height and
# width fields for the associated image; or height = width = 0
# indicates that the full resolution image was captured.

uint32 x_offset  # Leftmost pixel of the ROI
                 # (0 if the ROI includes the left edge of the image)
uint32 y_offset  # Topmost pixel of the ROI
                 # (0 if the ROI includes the top edge of the image)
uint32 height    # Height of ROI
uint32 width     # Width of ROI

# True if a distinct rectified ROI should be calculated from the "raw"
# ROI in this message. Typically this should be False if the full image
# is captured (ROI not used), and True if a subwindow is captured (ROI
# used).
bool do_rectify

Found sub-child custom schema Object location for: ros/sensor_msgs/regionofinterest, Schema File: # This message is used to specify a region of interest within an image.
#
# When used to specify the ROI setting of the camera when the image was
# taken, the height and width fields should either match the height and
# width fields for the associated image; or height = width = 0
# indicates that the full resolution image was captured.

uint32 x_offset  # Leftmost pixel of the ROI
                 # (0 if the ROI includes the left edge of the image)
uint32 y_offset  # Topmost pixel of the ROI
                 # (0 if the ROI includes the top edge of the image)
uint32 height    # Height of ROI
uint32 width     # Width of ROI

# True if a distinct rectified ROI should be calculated from the "raw"
# ROI in this message. Typically this should be False if the full image
# is captured (ROI not used), and True if a subwindow is captured (ROI
# used).
bool do_rectify

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/sensor_msgs/regionofinterest, Schema File: # This message is used to specify a region of interest within an image.
#
# When used to specify the ROI setting of the camera when the image was
# taken, the height and width fields should either match the height and
# width fields for the associated image; or height = width = 0
# indicates that the full resolution image was captured.

uint32 x_offset  # Leftmost pixel of the ROI
                 # (0 if the ROI includes the left edge of the image)
uint32 y_offset  # Topmost pixel of the ROI
                 # (0 if the ROI includes the top edge of the image)
uint32 height    # Height of ROI
uint32 width     # Width of ROI

# True if a distinct rectified ROI should be calculated from the "raw"
# ROI in this message. Typically this should be False if the full image
# is captured (ROI not used), and True if a subwindow is captured (ROI
# used).
bool do_rectify

Found sub-child custom schema Object location for: ros/sensor_msgs/regionofinterest, Schema File: # This message is used to specify a region of interest within an image.
#
# When used to specify the ROI setting of the camera when the image was
# taken, the height and width fields should either match the height and
# width fields for the associated image; or height = width = 0
# indicates that the full resolution image was captured.

uint32 x_offset  # Leftmost pixel of the ROI
                 # (0 if the ROI includes the left edge of the image)
uint32 y_offset  # Topmost pixel of the ROI
                 # (0 if the ROI includes the top edge of the image)
uint32 height    # Height of ROI
uint32 width     # Width of ROI

# True if a distinct rectified ROI should be calculated from the "raw"
# ROI in this message. Typically this should be False if the full image
# is captured (ROI not used), and True if a subwindow is captured (ROI
# used).
bool do_rectify

OutputHandler:
package ros.sensor_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.sensor_msgs.SetCameraInfo;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetCameraInfoOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetCameraInfoInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetCameraInfo this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetCameraInfoOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetCameraInfoInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[(((this_instruction.REQUEST.camera_info.header.length()+1)/2)+4) +4+4+(((this_instruction.REQUEST.camera_info.distortion_model.length()+1)/2)+4) +8+8+8+4+4+264];
this.this_instruction=(SetCameraInfo)instruction;
ros_msg[0] = (byte)((this_instruction.REQUEST.camera_info.height >>> 24) & 0xff);
ros_msg[1] = (byte)((this_instruction.REQUEST.camera_info.height >>> 16) & 0xff);
ros_msg[2] = (byte)((this_instruction.REQUEST.camera_info.height >>> 8) & 0xff);
ros_msg[3] = (byte)((this_instruction.REQUEST.camera_info.height >>> 0) & 0xff);

ros_msg[4] = (byte)((this_instruction.REQUEST.camera_info.width >>> 24) & 0xff);
ros_msg[5] = (byte)((this_instruction.REQUEST.camera_info.width >>> 16) & 0xff);
ros_msg[6] = (byte)((this_instruction.REQUEST.camera_info.width >>> 8) & 0xff);
ros_msg[7] = (byte)((this_instruction.REQUEST.camera_info.width >>> 0) & 0xff);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[0]);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[1]);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[2]);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[3]);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[4]);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[5]);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[6]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[7]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[8]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[0]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[1]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[2]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[3]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[4]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[5]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[6]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[7]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[8]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[0]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[1]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[2]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[3]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[4]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[5]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[6]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[7]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[8]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[9]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[10]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[11]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);

ros_msg[248] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 0) & 0xff);

ros_msg[256] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 24) & 0xff);
ros_msg[257] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 16) & 0xff);
ros_msg[258] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 8) & 0xff);
ros_msg[259] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 0) & 0xff);

ros_msg[260] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 24) & 0xff);
ros_msg[261] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 16) & 0xff);
ros_msg[262] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 8) & 0xff);
ros_msg[263] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 0) & 0xff);

ros_msg[264] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 24) & 0xff);
ros_msg[265] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 16) & 0xff);
ros_msg[266] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 8) & 0xff);
ros_msg[267] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 0) & 0xff);

ros_msg[268] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 24) & 0xff);
ros_msg[269] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 16) & 0xff);
ros_msg[270] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 8) & 0xff);
ros_msg[271] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 0) & 0xff);

ros_msg[272]=(byte)(((short)(this_instruction.REQUEST.camera_info.roi.do_rectify?1:0) >>> 0) & 0xff);


    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetCameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetCameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[(((this_instruction.REQUEST.camera_info.header.length()+1)/2)+4) +4+4+(((this_instruction.REQUEST.camera_info.distortion_model.length()+1)/2)+4) +8+8+8+4+4+264];
this.this_instruction=(SetCameraInfo)instruction;
ros_msg[0] = (byte)((this_instruction.REQUEST.camera_info.height >>> 24) & 0xff);
ros_msg[1] = (byte)((this_instruction.REQUEST.camera_info.height >>> 16) & 0xff);
ros_msg[2] = (byte)((this_instruction.REQUEST.camera_info.height >>> 8) & 0xff);
ros_msg[3] = (byte)((this_instruction.REQUEST.camera_info.height >>> 0) & 0xff);

ros_msg[4] = (byte)((this_instruction.REQUEST.camera_info.width >>> 24) & 0xff);
ros_msg[5] = (byte)((this_instruction.REQUEST.camera_info.width >>> 16) & 0xff);
ros_msg[6] = (byte)((this_instruction.REQUEST.camera_info.width >>> 8) & 0xff);
ros_msg[7] = (byte)((this_instruction.REQUEST.camera_info.width >>> 0) & 0xff);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[0]);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[1]);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[2]);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[3]);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[4]);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[5]);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[6]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[7]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[8]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[0]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[1]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[2]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[3]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[4]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[5]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[6]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[7]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[8]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[0]);
Aug 02, 2015 3:08:27 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[1]);
SEVERE: getFilePath(): null
Aug 02, 2015 3:08:27 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[2]);
Aug 02, 2015 3:08:27 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
Aug 02, 2015 3:08:27 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
Aug 02, 2015 3:08:27 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[3]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
SEVERE: getFilePath(): null
Aug 02, 2015 3:08:27 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
Aug 02, 2015 3:08:27 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSRunnableInstructionBuilder run
SEVERE: getFilePath(): null
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[4]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[5]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[6]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[7]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[8]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[9]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[10]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[11]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);

ros_msg[248] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 0) & 0xff);

ros_msg[256] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 24) & 0xff);
ros_msg[257] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 16) & 0xff);
ros_msg[258] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 8) & 0xff);
ros_msg[259] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 0) & 0xff);

ros_msg[260] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 24) & 0xff);
ros_msg[261] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 16) & 0xff);
ros_msg[262] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 8) & 0xff);
ros_msg[263] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 0) & 0xff);

ros_msg[264] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 24) & 0xff);
ros_msg[265] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 16) & 0xff);
ros_msg[266] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 8) & 0xff);
ros_msg[267] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 0) & 0xff);

ros_msg[268] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 24) & 0xff);
ros_msg[269] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 16) & 0xff);
ros_msg[270] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 8) & 0xff);
ros_msg[271] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 0) & 0xff);

ros_msg[272]=(byte)(((short)(this_instruction.REQUEST.camera_info.roi.do_rectify?1:0) >>> 0) & 0xff);



    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetCameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetCameraInfoOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetCameraInfoOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[(((this_instruction.REQUEST.camera_info.header.length()+1)/2)+4) +4+4+(((this_instruction.REQUEST.camera_info.distortion_model.length()+1)/2)+4) +8+8+8+4+4+264];
this.this_instruction=(SetCameraInfo)instruction;
ros_msg[0] = (byte)((this_instruction.REQUEST.camera_info.height >>> 24) & 0xff);
ros_msg[1] = (byte)((this_instruction.REQUEST.camera_info.height >>> 16) & 0xff);
ros_msg[2] = (byte)((this_instruction.REQUEST.camera_info.height >>> 8) & 0xff);
ros_msg[3] = (byte)((this_instruction.REQUEST.camera_info.height >>> 0) & 0xff);

ros_msg[4] = (byte)((this_instruction.REQUEST.camera_info.width >>> 24) & 0xff);
ros_msg[5] = (byte)((this_instruction.REQUEST.camera_info.width >>> 16) & 0xff);
ros_msg[6] = (byte)((this_instruction.REQUEST.camera_info.width >>> 8) & 0xff);
ros_msg[7] = (byte)((this_instruction.REQUEST.camera_info.width >>> 0) & 0xff);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[0]);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[1]);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[2]);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[3]);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[4]);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[5]);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[6]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[7]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.K[8]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[0]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[1]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[2]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[3]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[4]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[5]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[6]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[7]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.R[8]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[0]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[1]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[2]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[3]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[4]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[5]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[6]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[7]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[8]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[9]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[10]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.REQUEST.camera_info.P[11]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);

ros_msg[248] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 24) & 0xff);
ros_msg[249] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 16) & 0xff);
ros_msg[250] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 8) & 0xff);
ros_msg[251] = (byte)((this_instruction.REQUEST.camera_info.binning_x >>> 0) & 0xff);

ros_msg[252] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 24) & 0xff);
ros_msg[253] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 16) & 0xff);
ros_msg[254] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 8) & 0xff);
ros_msg[255] = (byte)((this_instruction.REQUEST.camera_info.binning_y >>> 0) & 0xff);

ros_msg[256] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 24) & 0xff);
ros_msg[257] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 16) & 0xff);
ros_msg[258] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 8) & 0xff);
ros_msg[259] = (byte)((this_instruction.REQUEST.camera_info.roi.x_offset >>> 0) & 0xff);

ros_msg[260] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 24) & 0xff);
ros_msg[261] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 16) & 0xff);
ros_msg[262] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 8) & 0xff);
ros_msg[263] = (byte)((this_instruction.REQUEST.camera_info.roi.y_offset >>> 0) & 0xff);

ros_msg[264] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 24) & 0xff);
ros_msg[265] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 16) & 0xff);
ros_msg[266] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 8) & 0xff);
ros_msg[267] = (byte)((this_instruction.REQUEST.camera_info.roi.height >>> 0) & 0xff);

ros_msg[268] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 24) & 0xff);
ros_msg[269] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 16) & 0xff);
ros_msg[270] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 8) & 0xff);
ros_msg[271] = (byte)((this_instruction.REQUEST.camera_info.roi.width >>> 0) & 0xff);

ros_msg[272]=(byte)(((short)(this_instruction.REQUEST.camera_info.roi.do_rectify?1:0) >>> 0) & 0xff);


        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetCameraInfoOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int array_length;
private long float64Long;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
    private long seq=0;
private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.SetLoggerLevel;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class SetLoggerLevelOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private SetLoggerLevelInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private SetLoggerLevel this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public SetLoggerLevelOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(SetLoggerLevelInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + SetLoggerLevelOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(SetLoggerLevelOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(SetLoggerLevel)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this.string_length=(this_instruction.REQUEST.logger.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.logger);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.string_length=(this_instruction.REQUEST.level.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.REQUEST.level);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            SetLoggerLevelOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
private java.lang.String str;
private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }private int soup;
private int y;
}


OutputHandler:
package ros.roscpp;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.roscpp.GetLoggers;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class GetLoggersOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private GetLoggersInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private GetLoggers this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public GetLoggersOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(GetLoggersInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getServiceSenders()[rosNode.getServiceIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;

    try 
    {
         // service is running and is connected.
         sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
    } 
    catch (NullPointerException e) 
    {
         throw e;
    } 
    catch (java.net.SocketException e) 
    {
          // Service is not running yet. Received SocketException, attempting reconnect.
          try 
          {
              sender.connect();
              sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + GetLoggersOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
          } 
          catch (Exception ex) 
          {
              // System.out.println("Failed Socket reconnect attempt on SocketException.");
              Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, "Failed Socket reconnect attempt on SocketException.", ex);
          }
      } 
      catch (Exception e) 
      {
           Logger.getLogger(GetLoggersOutputHandler.class.getName()).log(Level.SEVERE, null, e);            
      }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(GetLoggers)instruction;
        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            GetLoggersOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
}


Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

OutputHandler:
package ros.geometry_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.geometry_msgs.PoseStamped;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class PoseStampedOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private PoseStampedInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private PoseStamped this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public PoseStampedOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(PoseStampedInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[4];
this.this_instruction=(PoseStamped)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PoseStampedOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PoseStampedOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PoseStampedOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(PoseStamped)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);




    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PoseStampedOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PoseStampedOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PoseStampedOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[4];
this.this_instruction=(PoseStamped)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            PoseStampedOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
    private java.lang.String str;
private long float64Long;
    private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }    private int soup;
    private long seq=0;
    private int y;
}


Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Found sub-child custom schema Object location for: ros/geometry_msgs/pose, Schema File: # A representation of pose in free space, composed of postion and orientation. 
Point position
Quaternion orientation

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Found sub-child custom schema Object location for: ros/geometry_msgs/point, Schema File: # This contains the position of a point in free space
float64 x
float64 y
float64 z

Sub-child custom schema Objects not supported for this version of autonomous code generation
Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

Found sub-child custom schema Object location for: ros/geometry_msgs/quaternion, Schema File: # This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

OutputHandler:
package ros.geometry_msgs;

import org.happy.artist.rmdmia.utilities.BytesToHex;

import org.happy.artist.rmdmia.instruction.InstructionHandler;
import org.happy.artist.rmdmia.rcsm.provider.CommunicationSenderInterface;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.movement.MovementProcessor;
import ros.geometry_msgs.PoseWithCovarianceStamped;
import org.happy.artist.rmdmia.rcsm.RCSMException;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;
 
import org.happy.artist.rmdmia.instruction.Instruction;
import java.net.SocketException;
import java.lang.NullPointerException;
import org.happy.artist.rmdmia.movement.MovementProcessorFactory;
import org.happy.artist.rmdmia.timing.TimerService;

import org.happy.artist.rmdmia.instruction.providers.InstructionObjectPool;
import org.happy.artist.rmdmia.rcsm.providers.ros.ROSNode;
import java.io.IOException;
import org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.ROSMessageDefinitionTypeConverter;
import org.happy.artist.rmdmia.instruction.InstructionOutputHandler;
import org.happy.artist.rmdmia.utilities.ros.bag.RMDMIABagQueueFileWriter;

import java.util.logging.Level;

 /** * @author Happy Artist
 * 
 * @copyright Copyright © 2015 Happy Artist. All rights reserved.
 */
public class PoseWithCovarianceStampedOutputHandler extends MovementProcessor implements InstructionOutputHandler, MovementProcessorFactory
{
private PoseWithCovarianceStampedInstructionPool pool;
private ROSNode rosNode;
private CommunicationSenderInterface sender;
private InstructionHandler handler;
private java.lang.String topicName;
private PoseWithCovarianceStamped this_instruction;
private RMDMIABagQueueFileWriter rosBag;
private TimerService time;
private boolean isRecording=false;
public PoseWithCovarianceStampedOutputHandler(Controller controller, int hid)
{
    super();
    this.pool=(PoseWithCovarianceStampedInstructionPool)controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).getInstructionObjectPool();
    this.rosNode=(ROSNode)controller.getRCSM().getProviderByName("ros");
    if(controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name!=null&&controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name.isEmpty()==false)
    {
    this.topicName=controller.getInstructionManager().getProviderByName("instruction_manager").getInstructionDefinition(hid).name;
    this.sender=rosNode.getPublisherSenders()[rosNode.getTopicIndex(topicName)];
    }
    else
    {
    this.sender=null;
    }this.handler=new DefaultInstructionHandler();
        // Get reference to TimerService
        if((this.time=controller.getControllerManager().getTimerService())==null)
        {
            // Set default TimerService to microseconds. If user wants more or less precision they must set at startup.
            this.time = new TimerService(1,1,TimeUnit.MICROSECONDS);            
        }
        // Get a reference to rosBag
        this.rosBag=RMDMIABagQueueFileWriter.getInstance();    
}
    /** Set boolean isRecording. */
    public void setIsRecording(boolean isRecording)
    {
        this.isRecording=isRecording;
    }

    /** Return is recording. */
    public boolean getIsRecording()
    {
        return isRecording;
    }
    /** This call to process will send the message to the RCSM via the Movement 
     *  Processor Manager (after pre-ordered movement calibrations processed). 
     * 
     * @param instruction
     * @return 
     */
    @Override
    public Instruction process(Instruction instruction)
    {        
final byte[] ros_msg = new byte[296];
this.this_instruction=(PoseWithCovarianceStamped)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[0]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[1]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[2]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[3]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[4]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[5]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[6]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[7]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[8]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[9]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[10]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[11]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[12]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[13]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[14]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[15]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
Aug 02, 2015 3:08:34 PM org.happy.artist.rmdmia.instruction.providers.InstructionManagerPlugin initialize
INFO: Compiling Instructions...
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[16]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[17]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[18]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[19]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[20]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[21]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[22]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[23]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[24]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[25]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[26]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[27]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[28]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[29]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[30]);
ros_msg[296] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[297] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[298] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[299] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[300] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[301] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[302] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[303] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[31]);
ros_msg[304] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[305] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[306] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[307] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[308] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[309] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[310] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[311] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[32]);
ros_msg[312] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[313] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[314] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[315] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[316] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[317] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[318] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[319] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[33]);
ros_msg[320] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[321] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[322] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[323] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[324] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[325] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[326] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[327] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[34]);
ros_msg[328] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[329] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[330] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[331] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[332] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[333] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[334] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[335] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[35]);
ros_msg[336] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[337] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[338] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[339] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[340] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[341] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[342] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[343] = (byte)((float64Long >> 0) & 0xffL);


    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PoseWithCovarianceStampedOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PoseWithCovarianceStampedOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PoseWithCovarianceStampedOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    return instruction;      
    }

    /** Send the message directly to the RCSM, and checkin the Instruction 
     *  to the Instruction Object Pool if the pool is not null, if pool 
     *  is null set the Object to null. 
     * 
     * @param instruction
     */
    @Override
    public void send(Instruction instruction)
    {
final byte[] ros_msg = new byte[296];
this.this_instruction=(PoseWithCovarianceStamped)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[0]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[1]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[2]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[3]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[4]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[5]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[6]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[7]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[8]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[9]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[10]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[11]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[12]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[13]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[14]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[15]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[16]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[17]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[18]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[19]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[20]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[21]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[22]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[23]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[24]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[25]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[26]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[27]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[28]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[29]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[30]);
ros_msg[296] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[297] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[298] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[299] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[300] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[301] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[302] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[303] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[31]);
ros_msg[304] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[305] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[306] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[307] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[308] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[309] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[310] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[311] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[32]);
ros_msg[312] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[313] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[314] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[315] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[316] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[317] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[318] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[319] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[33]);
ros_msg[320] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[321] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[322] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[323] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[324] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[325] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[326] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[327] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[34]);
ros_msg[328] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[329] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[330] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[331] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[332] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[333] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[334] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[335] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[35]);
ros_msg[336] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[337] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[338] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[339] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[340] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[341] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[342] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[343] = (byte)((float64Long >> 0) & 0xffL);



    if(sender!=null)
    {
        try
        {
            sender.send(ros_msg);
            if(isRecording)
            {
                // Record
                try 
                {
                    // Send the message to the ROS Bag file.
                        rosBag.addMessage(TimerService.SYSTEM_TIME, instruction.hid, BytesToHex.bytesToHexChars(ros_msg));
                } 
                catch (IOException exc) 
                {
                        Logger.getLogger(PoseWithCovarianceStampedOutputHandler.class.getName()).log(Level.SEVERE, java.lang.String.valueOf(TimerService.SYSTEM_TIME) + " rosbag recording failed to add Message for topic/service: "  + PoseWithCovarianceStampedOutputHandler.this.topicName + " hid: " + java.lang.String.valueOf(instruction.hid), exc);
                }                
            }
        }
        catch (IOException ex)
        {
            Logger.getLogger(PoseWithCovarianceStampedOutputHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
        if(pool!=null)
        {
           pool.checkin(this_instruction.eid);        
        }     
        else
        {
            instruction=null;
        }
    }

    /** Transform Instruction Object into associated RCSM plugin outgoing 
     * connection byte[] format.
     * 
     * @return byte[] outgoing message format byte[]
     */ 
   @Override
    public byte[] transform(Instruction instruction)
    {
final byte[] ros_msg = new byte[296];
this.this_instruction=(PoseWithCovarianceStamped)instruction;
int current_position=0;
int length;// TODO: This may only apply to InputHandler, and not OutputHandler verify...
this_instruction.header.seq=(this.seq=seq + 1);
ros_msg[current_position] = (byte)((this_instruction.header.seq >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.seq >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.seq >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.seq >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.secs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.secs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.secs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.secs >>> 0) & 0xff);
current_position = current_position + 4;
ros_msg[current_position] = (byte)((this_instruction.header.stamp.nsecs >>> 24) & 0xff);
ros_msg[current_position+1] = (byte)((this_instruction.header.stamp.nsecs >>> 16) & 0xff);
ros_msg[current_position+2] = (byte)((this_instruction.header.stamp.nsecs >>> 8) & 0xff);
ros_msg[current_position+3] = (byte)((this_instruction.header.stamp.nsecs >>> 0) & 0xff);
current_position = current_position + 4;
this.string_length=(this_instruction.header.frame_id.length()+1)/2;
ros_msg[current_position=current_position+3] = (byte)((string_length >>> 24) & 0xff);
ros_msg[current_position=current_position+2] = (byte)((string_length >>> 16) & 0xff);
ros_msg[current_position=current_position+1] = (byte)((string_length >>> 8) & 0xff);
ros_msg[current_position] = (byte)((string_length >>> 0) & 0xff);
current_position=current_position+1;
      try
{
this.str=hexStringConverter.stringToHex(this_instruction.header.frame_id);
}
catch(java.io.UnsupportedEncodingException exc)
{
java.util.logging.Logger.getLogger(new Throwable() .getStackTrace()[0].getClassName()).log(Level.SEVERE, null, exc);
}
      if (str.length() != 0) 
      {
      ros_msg[current_position] = 0;
      this.soup = (str.length() % 2);
      this.y = current_position;
      while (y < (current_position+str.length())) 
      {
        char c = str.charAt(y);
        if (!isHex(c)) {
            
          throw new IllegalArgumentException("string contains non-hex chars: "+c);
        }
        if ((soup % 2) == 0) 
        {
          ros_msg[soup >> 1] = (byte) (hexValue(c) << 4);
        } 
        else 
        {
          ros_msg[soup >> 1] += (byte) hexValue(c);
        }
        soup=soup+1;
        y=y+1;
      }
      }
current_position=current_position+string_length;
this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.x);
ros_msg[0] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[1] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[2] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[3] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[4] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[5] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[6] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[7] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.y);
ros_msg[8] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[9] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[10] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[11] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[12] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[13] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[14] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[15] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.position.z);
ros_msg[16] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[17] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[18] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[19] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[20] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[21] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[22] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[23] = (byte)((float64Long >> 0) & 0xffL);


this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.x);
ros_msg[24] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[25] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[26] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[27] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[28] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[29] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[30] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[31] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.y);
ros_msg[32] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[33] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[34] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[35] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[36] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[37] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[38] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[39] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.z);
ros_msg[40] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[41] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[42] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[43] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[44] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[45] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[46] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[47] = (byte)((float64Long >> 0) & 0xffL);

this.float64Long=Double.doubleToLongBits(this_instruction.pose.pose.orientation.w);
ros_msg[48] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[49] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[50] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[51] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[52] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[53] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[54] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[55] = (byte)((float64Long >> 0) & 0xffL);



this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[0]);
ros_msg[56] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[57] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[58] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[59] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[60] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[61] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[62] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[63] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[1]);
ros_msg[64] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[65] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[66] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[67] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[68] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[69] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[70] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[71] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[2]);
ros_msg[72] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[73] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[74] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[75] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[76] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[77] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[78] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[79] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[3]);
ros_msg[80] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[81] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[82] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[83] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[84] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[85] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[86] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[87] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[4]);
ros_msg[88] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[89] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[90] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[91] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[92] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[93] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[94] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[95] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[5]);
ros_msg[96] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[97] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[98] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[99] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[100] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[101] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[102] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[103] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[6]);
ros_msg[104] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[105] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[106] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[107] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[108] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[109] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[110] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[111] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[7]);
ros_msg[112] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[113] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[114] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[115] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[116] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[117] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[118] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[119] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[8]);
ros_msg[120] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[121] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[122] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[123] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[124] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[125] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[126] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[127] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[9]);
ros_msg[128] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[129] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[130] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[131] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[132] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[133] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[134] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[135] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[10]);
ros_msg[136] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[137] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[138] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[139] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[140] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[141] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[142] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[143] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[11]);
ros_msg[144] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[145] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[146] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[147] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[148] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[149] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[150] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[151] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[12]);
ros_msg[152] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[153] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[154] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[155] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[156] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[157] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[158] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[159] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[13]);
ros_msg[160] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[161] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[162] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[163] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[164] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[165] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[166] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[167] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[14]);
ros_msg[168] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[169] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[170] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[171] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[172] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[173] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[174] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[175] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[15]);
ros_msg[176] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[177] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[178] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[179] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[180] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[181] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[182] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[183] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[16]);
ros_msg[184] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[185] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[186] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[187] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[188] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[189] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[190] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[191] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[17]);
ros_msg[192] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[193] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[194] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[195] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[196] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[197] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[198] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[199] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[18]);
ros_msg[200] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[201] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[202] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[203] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[204] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[205] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[206] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[207] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[19]);
ros_msg[208] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[209] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[210] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[211] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[212] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[213] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[214] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[215] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[20]);
ros_msg[216] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[217] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[218] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[219] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[220] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[221] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[222] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[223] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[21]);
ros_msg[224] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[225] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[226] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[227] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[228] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[229] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[230] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[231] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[22]);
ros_msg[232] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[233] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[234] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[235] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[236] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[237] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[238] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[239] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[23]);
ros_msg[240] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[241] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[242] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[243] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[244] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[245] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[246] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[247] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[24]);
ros_msg[248] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[249] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[250] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[251] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[252] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[253] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[254] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[255] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[25]);
ros_msg[256] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[257] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[258] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[259] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[260] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[261] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[262] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[263] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[26]);
ros_msg[264] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[265] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[266] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[267] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[268] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[269] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[270] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[271] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[27]);
ros_msg[272] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[273] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[274] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[275] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[276] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[277] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[278] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[279] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[28]);
ros_msg[280] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[281] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[282] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[283] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[284] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[285] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[286] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[287] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[29]);
ros_msg[288] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[289] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[290] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[291] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[292] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[293] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[294] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[295] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[30]);
ros_msg[296] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[297] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[298] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[299] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[300] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[301] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[302] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[303] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[31]);
ros_msg[304] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[305] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[306] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[307] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[308] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[309] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[310] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[311] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[32]);
ros_msg[312] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[313] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[314] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[315] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[316] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[317] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[318] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[319] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[33]);
ros_msg[320] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[321] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[322] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[323] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[324] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[325] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[326] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[327] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[34]);
ros_msg[328] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[329] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[330] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[331] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[332] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[333] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[334] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[335] = (byte)((float64Long >> 0) & 0xffL);
this.float64Long=Double.doubleToLongBits(this_instruction.pose.covariance[35]);
ros_msg[336] = (byte)((float64Long >> 56) & 0xffL);
ros_msg[337] = (byte)((float64Long >> 48) & 0xffL);
ros_msg[338] = (byte)((float64Long >> 40) & 0xffL);
ros_msg[339] = (byte)((float64Long >> 32) & 0xffL);
ros_msg[340] = (byte)((float64Long >> 24) & 0xffL);
ros_msg[341] = (byte)((float64Long >> 16) & 0xffL);
ros_msg[342] = (byte)((float64Long >> 8) & 0xffL);
ros_msg[343] = (byte)((float64Long >> 0) & 0xffL);


        return ros_msg;
    }

     /** Process the instruction via the registered InstructionHandler. If the Handler 
     * is not registered, the default instruction handler will checkin the Instruction 
     * to the Instruction Object Pool. This particular method is intended for autonomous 
     * data processing (Artificial Intelligence). In reality most implementations will 
     * call getRegisteredInstructionHandler, and call process directly for performance and custom
     * AI interface implementations for improved performance.
     * 
     * @param process_instruction
     */
    public void process_handler(Instruction process_instruction)
    {
        handler.process(process_instruction);        
    }

    @Override
    public MovementProcessor newMovementProcessor()
    {
    return (MovementProcessor)this;
    }

    /** Register an InstructionHandler, that will send the Instruction to its next destination, 
     * after the byte[] conversion  to Instruction is completed. If not registered process will call
     * checkin on the Instruction Object.
     */
   public void registerInstructionHandler(InstructionHandler handler)
   {
	this.handler=handler;
   }
    
    /** Return boolean is InstructionHandler Registered.
     * 
     * @return boolean 
     */
    public boolean isRegistered()
    {
	if(handler==null)
	{
           return false;
	}
	return true;
    }
    
    /** Return the Registered InstructionHandler. Returns null if an InstructionHandler is not Registered. */
   public InstructionHandler getRegisteredInstructionHandler()
   {
	return handler;
   }
    
    class DefaultInstructionHandler implements InstructionHandler
    {
        /** A default InstructionHandler that automatically checks in the Instruction Object
         * if an InstructionHandler is not set.
         * 
         * @param instruction 
         */
        @Override
        public void process(Instruction instruction)
        {
            PoseWithCovarianceStampedOutputHandler.this.pool.checkin(instruction.eid);
        }
        
    }

    /** Return the InstructionObjectPool associated with the InstructionOutputHandler implementation. Return null, if it is not implemented in the InstructionOutputHandler. */
    public InstructionObjectPool getInstructionObjectPool()
    {
        return pool;
    }    
    private java.lang.String str;
private int array_length;
private long float64Long;
    private int string_length;
    private org.happy.artist.rmdmia.utilities.HexStringConverter hexStringConverter = org.happy.artist.rmdmia.utilities.HexStringConverter.getHexStringConverterInstance();
private int j;
    private static boolean isHex(char c) {
        return ((c >= '0') && (c <= '9')) ||
               ((c >= 'a') && (c <= 'f')) ||
               ((c >= 'A') && (c <= 'F'));
      }

      private static int hexValue(char c) {
        if ((c >= '0') && (c <= '9')) {
          return (c - '0');
        } else if ((c >= 'a') && (c <= 'f')) {
          return (c - 'a') + 10;
        } else {
          return (c - 'A') + 10;
        }
      }    private int soup;
    private long seq=0;
    private int y;
}


No Message definition available for service /rviz/set_logger_level source generation, need to create a ROS_Message Instruction as workaround!!!!!!
No Message definition available for service /rviz/reload_shaders source generation, need to create a ROS_Message Instruction as workaround!!!!!!
No Message definition available for service /rviz/get_loggers source generation, need to create a ROS_Message Instruction as workaround!!!!!!
Aug 02, 2015 3:08:56 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.MessageCompiler$MessageDiagnosticListener report
WARNING: Line Number->86
code->compiler.err.cant.resolve.location.args
Message->cannot find symbol
  symbol:   method length()
  location: variable header of type org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.type.std_msgs.Header
Line Number->86
Source->org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.MessageCompiler$DynamicSourceCodeObject[string:///SetCameraInfoOutputHandler.java]
 
Aug 02, 2015 3:08:56 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.MessageCompiler$MessageDiagnosticListener report
WARNING: Line Number->469
code->compiler.err.cant.resolve.location.args
Message->cannot find symbol
  symbol:   method length()
  location: variable header of type org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.type.std_msgs.Header
Line Number->469
Source->org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.MessageCompiler$DynamicSourceCodeObject[string:///SetCameraInfoOutputHandler.java]
 
Aug 02, 2015 3:08:56 PM org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.MessageCompiler$MessageDiagnosticListener report
WARNING: Line Number->859
code->compiler.err.cant.resolve.location.args
Message->cannot find symbol
  symbol:   method length()
  location: variable header of type org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.type.std_msgs.Header
Line Number->859
Source->org.happy.artist.rmdmia.rcsm.providers.ros.client.message.generator.MessageCompiler$DynamicSourceCodeObject[string:///SetCameraInfoOutputHandler.java]
 
Aug 02, 2015 3:08:57 PM org.happy.artist.rmdmia.instruction.providers.InstructionManagerPlugin initialize
INFO: Instruction Manager initialized
Aug 02, 2015 3:08:57 PM org.happy.artist.rmdmia.perception.engine.PEManager initialize
INFO: Starting Perception Engine Plugin: ros_pe_provider_v1.0
ros_pe_provider_v1.0 Properties: conf/pe/ros_pe_provider_v1.0.properties
Aug 02, 2015 3:08:57 PM org.happy.artist.rmdmia.perception.engine.plugins.ROSPEProvider initialize
INFO: Initializing ROS Perception Engine plugin.
SensorProcessorRegistry keys length is less than 1. Generating default values.
Aug 02, 2015 3:08:57 PM org.happy.artist.rmdmia.perception.engine.sensor.utility.Utility generateDefaultSensorProcessorTopicsWithROSBag
INFO: Populating the default Perception Engine Sensor Processor Manager registry sensor_message_queue.eax.
Aug 02, 2015 3:08:59 PM org.happy.artist.rmdmia.perception.engine.plugins.ROSPEProvider initialize
INFO: ROS Perception Engine initialized
Aug 02, 2015 3:09:00 PM org.happy.artist.rmdmia.roci.ROCIManager initialize
INFO: Starting ROCI Plugin: rosbag_test_gui_v1.0
rosbag_test_gui_v1.0 Properties: conf/roci/rosbag_test_gui_v1.0.properties
Aug 02, 2015 3:09:01 PM org.happy.artist.rmdmia.roci.ROCIManager initialize
INFO: Starting ROCI Plugin: ros_configuration_manager_v1.0
ros_configuration_manager_v1.0 Properties: conf/roci/ros_configuration_manager_v1.0.properties
Aug 02, 2015 3:09:01 PM org.happy.artist.rmdmia.roci.plugins.ROSBagControllerPlugin initialize
INFO: Initializing rosbag test GUI plugin.
Aug 02, 2015 3:09:01 PM org.happy.artist.rmdmia.roci.plugins.ROSBagControllerPlugin initialize
INFO: ROSPEProvider is initialized proceeding to launch rosbag test GUI..
Aug 02, 2015 3:09:02 PM org.happy.artist.rmdmia.roci.plugins.ROSBagControllerPlugin initialize
INFO: ROCI rosbag test GUI plugin initialized
Aug 02, 2015 3:09:02 PM org.happy.artist.rmdmia.roci.plugins.ROSConfigurationManager initialize
INFO: Initializing ROS Configuration Manager GUI Tool.
Aug 02, 2015 3:09:02 PM org.happy.artist.rmdmia.roci.plugins.ROSConfigurationManager initialize
INFO: Opening ROS ROCI Configuration Manager GUI Tool.
BUILD STOPPED (total time: 2 minutes 11 seconds)
