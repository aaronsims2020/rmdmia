package org.happy.artist.rmdmia.instruction.providers;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.happy.artist.rmdmia.Controller;
import org.happy.artist.rmdmia.instruction.InstructionDefinition;
import org.happy.artist.rmdmia.instruction.InstructionManagerHardwareRegistry;
import org.happy.artist.rmdmia.instruction.InstructionManagerProvider;
import org.happy.artist.rmdmia.rcsm.provider.message.MessageCompiler;
import org.happy.artist.rmdmia.utilities.HexStringConverter;

/** A single RMDMIA source for all Instruction Object Lookups by Hardware ID,
 * that includes Instruction Object, Message to Instruction Converters,
 * Instruction to Message Converter classes, associated API documentation
 * and checkin/checkout of those Objects from Object Pools. Hardware IDs
 * that are unregistered to a Instruction items are also available here.
 *
 * @author Happy Artist
 * 
 * @copyright Copyright Â©2014 Happy Artist. All rights reserved.
 */
public class InstructionManagerPlugin extends InstructionManagerProvider
{
 // TODO: Implement Reusuable Object Pools (Minimum on Instructions)
// TODO: Implement Source code generator for classes that do not exist. 
// On Calls to get Instruction Object generate Object on the fly with SRC Generator
// TODO: Generate Javadocs for autogenerated classes (Maybe make available to all
// TODO: Think about renaming the InstructionManagerPlugin, and making available via static reference in the RMDMIA ControllerManager... Maybe call the HardwareEventManager
// TODO: If sufficient information is not available to generate a generic ROSMessage based instruction class if ros is the RCSM source.
    
    // perception Engine Provider variables
    private final static String name="instruction_manager"; 
    private final static double version = 1.0;     
    private final static InstructionManagerHardwareRegistry registry = InstructionManagerHardwareRegistry.getInstance();    
    private Properties properties;
    // initialize method variables
    private boolean isInitialized=false;
    // Thread to run the controller loop.
    private Thread thread;  
    // HashMap index for topic/service lookup
    HashMap<String,Integer> map = new HashMap<String,Integer>();
    
// Instruction with a ROSMessage attached.
   private Controller controller;
   private InstructionDefinition[] definitions;
   private HexStringConverter hexToString =HexStringConverter.getHexStringConverterInstance();
//   private Instruction[] instructions;
//   private InstructionInputHandler[] inputs;
//   private InstructionOutputHandler[] outputs;
//   private int[] hids;
    // Class Logger define & instantiation
    private final static Logger logger = Logger.getLogger(InstructionManagerPlugin.class.getName());     
   
    public InstructionManagerPlugin(Controller controller)
   {
       this.controller=controller;
   }
    
  
   /** Custom InstructionDefinitions can be added post startup using setInstructionDefinition. */ 
   public void setInstructionDefinition(int hid, InstructionDefinition definition)
   {
       definitions[hid]=definition;
   }
      
   /** Low performance method used for unit tests. */
   public int[] getHids()
   {
       int[] hids=new int[definitions.length];
       for(int i=0;i<hids.length;i++)
       {
           hids[i]=definitions[i].hid;
       }
       return hids;
   }
   
   /** Add a new hid with default InstructionDefinition. Return the hid. */
   public int addHid(String rcsm_provider_name)
   {
       Arrays.copyOf(definitions, definitions.length+1);
       // Instantiate InstructionDefinition
       definitions[definitions.length-1]=controller.getRCSM().getProviderByName(rcsm_provider_name).getInstructionDefinition();
       // assign new hid
       definitions[definitions.length-1].hid=definitions.length-1;
       // assign provider name
       definitions[definitions.length-1].provider_name=rcsm_provider_name;
       map.put(definitions[definitions.length-1].name,definitions[definitions.length-1].hid);
       return definitions.length-1;
   }

   /** Add a new hid. Pass in InstructionDefinition implementation. Return the hid. */
   public int addHid(String rcsm_provider_name, InstructionDefinition definition)
   {
       Arrays.copyOf(definitions, definitions.length+1);
       // Instantiate InstructionDefinition
       definitions[definitions.length-1]=definition;
       // assign new hid
       definitions[definitions.length-1].hid=definitions.length-1;
       // assign provider name
       definitions[definitions.length-1].provider_name=rcsm_provider_name;
       map.put(definitions[definitions.length-1].name,definitions[definitions.length-1].hid);       
       return definitions.length-1;
   }   
   
   /** Add a new hid. Return the hid*/
   public InstructionDefinition getInstructionDefinition(int hid)
   {
       return definitions[hid];
   }
   
   /** Return Instruction Definition by name.
    * @param name String the name of the definition.
    * @return InstructionDefinition
    */
   public InstructionDefinition getInstructionDefinition(String name)
   {
       final Integer definition_hid=map.get(name);
       if(definition_hid!=null)
       {
           return definitions[definition_hid];
       }
       return null;
   }   

   /** Return hid by instruction name.
    * @param name String the name of the instruction.
    * @return int hid. -1 id instruction definition for name not defined.
    */
   public int getHidByName(String name)
   {
       final Integer definition_hid=map.get(name);
       if(definition_hid!=null)
       {
           return definition_hid;
       }
       return -1;
   }   
   
   /** Return hid by instruction name.
    * @param hid int of the instruction.
    * @return String instruction name. null returned if hid not defined.
    */
   public String getNameByHid(int hid)
   {
       if(hid<definitions.length&&definitions[hid]!=null)
       {
           return definitions[hid].name;
       }
       return null;
   }     
   
    /** Return the plugin version number. A version number of 0 is default of no version number. */
    @Override
    public double getVersion() 
    {
        return version;
    }
 
    /** Return the Perception Engine Plugin name. */ 
    @Override
    public String getName() 
    {
        return name;
    }

    @Override
    public boolean recycle() 
    {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void shutdown() 
    {
        this.thread=null;
        // Set isInitialized to false.
        this.isInitialized=false;   
    }

    /** Return boolean is initialized on Perception Engine Provider. 
     * @return boolean returns false if Perception Engine Provider is not initialized. 
     */   
    @Override
    public boolean isInitialized() 
    {
        if(isInitialized&&controller.getInstructionManager().isInitialized())
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    private Object[] keys;
    private int highestInt=0;
    private int currentInt;
    private String provider_name_temp;
    @Override
    public void initialize() 
    {
        logger.log(Level.INFO, "Initializing Instruction Manager plugin.");       
        // Setup the Perception Engine Plugin properties.
        this.properties=getProperties();
// TODO: Initialize definitions array       
        this.keys = registry.getProperties().keySet().toArray();
        // a single hid is 5 keys, and default 2 keys for folder conifiguration.
        if(keys.length<1)
        {
            System.out.println("InstructionManagerProperties keys length is less than 1. Generating default values.");
            // if true reset keys
            //System.out.println("registry:" + registry);
            //System.out.println("controller:" + controller);            
            try 
            {
                if(org.happy.artist.rmdmia.instruction.utility.Utility.generateDefaultInstructionManagerTopicsWithRegisteredRCSMProviders(controller, registry))
                {
                    this.keys = registry.getProperties().keySet().toArray();
                }
            } 
            catch (UnsupportedEncodingException ex) 
            {
                Logger.getLogger(InstructionManagerPlugin.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
     
        // Define definitions length to keys.length/5
        // Find the highest hid key number
        this.highestInt=0;
        for(int i=0;i<keys.length;i++)
        {
            try
            {
                this.currentInt=Integer.parseInt(((String)keys[i]).split("\\.")[0]);
                if(currentInt>highestInt)
                {
                    this.highestInt=currentInt;
                }
            }
            catch(NumberFormatException e)
            {
                // Ignore onlylooking for numbers
            }
            catch(ArrayIndexOutOfBoundsException e)
            {
                Logger.getLogger(InstructionManagerPlugin.class.getName()).log(Level.WARNING, null, e);
            }
        }
        // Initialize definitions to highestInt + 1
        this.definitions=new InstructionDefinition[highestInt+1];
        // Populate InstructionDefinitions Array
        for(int i=0;i<definitions.length;i++)
        {
           // Get the provider name
            this.provider_name_temp=InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".5"));
            if(provider_name_temp!=null)
            {
                definitions[i]=controller.getRCSM().getProviderByName(provider_name_temp).getInstructionDefinition();
                definitions[i].setName(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".0")));
                definitions[i].setDescription(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".1")));
                definitions[i].setInstructionObjectClassName(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".2")));
                definitions[i].setInstructionInputHandlerClassName(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".3")));
                definitions[i].setInstructionOutputHandlerClassName(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".4")));
                definitions[i].setSchemaIsFixedLength(Boolean.parseBoolean(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".6"))));
                definitions[i].provider_name=provider_name_temp;
                definitions[i].provider_version=InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".10"));
                if(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".7"))!=null&&!InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".7")).isEmpty())
                {
                        if(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".7")).matches("[0-9A-F]+"))
                        {
                            definitions[i].setSchema(hexToString.hexToString(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".7"))));
                        }
                        else
                        {
                            definitions[i].setSchema("");
                        }
                }
                else
                {
                    definitions[i].setSchema("");
                }
                definitions[i].setInstructionObjectPoolClassName(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".8")));     
                if(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".9"))!=null&&!InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".9")).isEmpty())
                {
                    try
                    {
                        definitions[i].setSchemaTypeMessageLength(Integer.parseInt(InstructionManagerHardwareRegistry.get(String.valueOf(i).concat(".9"))));
                    }
                    catch(Exception e)
                    {
                        // Defaults to 1024 length.
                        definitions[i].setSchemaTypeMessageLength(1024);
                    }
                }
                else
                {
                        // Defaults to 1024 length.
                        definitions[i].setSchemaTypeMessageLength(1024);                    
                }
                definitions[i].hid=i;
            }
        }
        
        // Check if Classes exist in classpath with Class.forName, and on ClassNotFoundException for an InstructionDefinition call that definition method getSource, and append that data to a Collective ArrayList, that if not null will be compiled via the MessageCompiler.          
        
        Map<String,List<MessageCompiler.DynamicSourceCodeObject>> dynamic_source_code_object_list_map=new HashMap<String,List<MessageCompiler.DynamicSourceCodeObject>>();       
        List<MessageCompiler.DynamicSourceCodeObject> dynamic_source_code_object_list=null;
        
        for(int i=0;i<definitions.length;i++)
        {
            // if input_handler_class_name is not null, and not an empty String
            if(definitions[i].instruction_input_handler_class_name!=null&&definitions[i].instruction_input_handler_class_name.isEmpty()==false)
            {
                try
                {
                    // Check if Class is in Classpath, otherwise generate source code, and add to ArrayList.
                    Class.forName(definitions[i].instruction_input_handler_class_name);
                }
                catch(ClassNotFoundException e)
                {
                    if(dynamic_source_code_object_list_map.get(definitions[i].provider_name)!=null)
                    {
                        dynamic_source_code_object_list=dynamic_source_code_object_list_map.get(definitions[i].provider_name);
                    }
                    else
                    {
                        dynamic_source_code_object_list=new ArrayList<MessageCompiler.DynamicSourceCodeObject>();
                    }
                    
                    dynamic_source_code_object_list.addAll(definitions[i].getSource());
                    dynamic_source_code_object_list_map.put(definitions[i].provider_name, dynamic_source_code_object_list);
                    e.printStackTrace();
                }
            }
            else if(definitions[i].getName()!=null&&definitions[i].getName().isEmpty()==false)
            {
                // TODO: Fix this so a call to getInstructionInputHandler is not required to register the class names with the INstruction Registry
                //definitions[i].getInstructionInputHandler();
                if(dynamic_source_code_object_list_map.get(definitions[i].provider_name)!=null)
                {
                    dynamic_source_code_object_list=dynamic_source_code_object_list_map.get(definitions[i].provider_name);
                }
                else
                {
                    dynamic_source_code_object_list=new ArrayList<MessageCompiler.DynamicSourceCodeObject>();
                }
                dynamic_source_code_object_list.addAll(definitions[i].getSource());                
                dynamic_source_code_object_list_map.put(definitions[i].provider_name, dynamic_source_code_object_list);                
            }
            map.put(definitions[i].name,definitions[i].hid);
        }        
        // If dynamic_source_code_object_array is not null, call MessageCompiler on the dynamic_source_code_object_array

        Object[] keys = dynamic_source_code_object_list_map.keySet().toArray();
        for(int i=0;i<keys.length;i++)
        {
            dynamic_source_code_object_list=dynamic_source_code_object_list_map.get((String)keys[i]);
            if(dynamic_source_code_object_list!=null&&dynamic_source_code_object_list.size()>0)
            {
                String classFolderPath=null;
                try 
                {   
                    classFolderPath=getController().getInstructionManager().getClassFolderPath();
                    if(classFolderPath.endsWith("/")==false)
                    {
                        classFolderPath=classFolderPath.concat("/");
                    }
    // TODO: Figure out how to compile each set of Object Instructions in the right provider directory...                
                    classFolderPath=classFolderPath.concat((String)keys[i]).concat("/");
                    logger.log(Level.INFO, "Compiling Instructions...");                
                    // Compile the Dynamic Source Code List
                    MessageCompiler.compile(dynamic_source_code_object_list, classFolderPath);
                    // Update classmap and return the new type...
                    controller.getInstructionManager().updateClassLookupMap((String)keys[i]);
                    // Update the configuration with the new classes.
                    InstructionManagerHardwareRegistry.writeFile(); 
                }
                catch(NullPointerException ex)
                {
                    Logger.getLogger(InstructionManagerPlugin.class.getName()).log(Level.SEVERE, "NullPointerException attempting to compile Instructions for ".concat((String)keys[i]).concat(" RCSM provider..."), ex);
                }
                catch (Exception ex)
                {
                    Logger.getLogger(InstructionManagerPlugin.class.getName()).log(Level.SEVERE, "Exception attempting to compile Instructions for ".concat((String)keys[i]).concat(" RCSM provider..."), ex);
                }
            }
        }
        // Set isInitialized to true.
        this.isInitialized=true;                  
        logger.log(Level.INFO, "Instruction Manager initialized");
    }
 
}
